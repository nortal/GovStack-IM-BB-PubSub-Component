/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApiErrorResponse
 */
export interface ApiErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ApiErrorResponse
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiErrorResponse
     */
    'message'?: string;
}
/**
 * Create Event Type
 * @export
 * @interface CreateEventType
 */
export interface CreateEventType {
    /**
     * Identifies the event type
     * @type {string}
     * @memberof CreateEventType
     */
    'identifier': string;
    /**
     * The version number
     * @type {number}
     * @memberof CreateEventType
     */
    'versionNo': number;
    /**
     * The version json schema
     * @type {string}
     * @memberof CreateEventType
     */
    'schema': string;
}
/**
 * Create Event Type Version
 * @export
 * @interface CreateEventTypeVersion
 */
export interface CreateEventTypeVersion {
    /**
     * The version number
     * @type {number}
     * @memberof CreateEventTypeVersion
     */
    'versionNo': number;
    /**
     * The version json schema
     * @type {string}
     * @memberof CreateEventTypeVersion
     */
    'schema': string;
}
/**
 * Create Manager Request
 * @export
 * @interface CreateManagerRequest
 */
export interface CreateManagerRequest {
    /**
     * Identifies the manager
     * @type {string}
     * @memberof CreateManagerRequest
     */
    'identifier': string;
    /**
     * The identifier type
     * @type {string}
     * @memberof CreateManagerRequest
     */
    'identifierType': CreateManagerRequestIdentifierTypeEnum;
}

export const CreateManagerRequestIdentifierTypeEnum = {
    Internal: 'INTERNAL',
    Xroad: 'XROAD'
} as const;

export type CreateManagerRequestIdentifierTypeEnum = typeof CreateManagerRequestIdentifierTypeEnum[keyof typeof CreateManagerRequestIdentifierTypeEnum];

/**
 * Create Publisher Request
 * @export
 * @interface CreatePublisherRequest
 */
export interface CreatePublisherRequest {
    /**
     * Identifies the publisher
     * @type {string}
     * @memberof CreatePublisherRequest
     */
    'identifier': string;
    /**
     * The identifier type
     * @type {string}
     * @memberof CreatePublisherRequest
     */
    'identifierType': CreatePublisherRequestIdentifierTypeEnum;
    /**
     * The publisher\'s event types
     * @type {Array<string>}
     * @memberof CreatePublisherRequest
     */
    'eventTypes': Array<string>;
}

export const CreatePublisherRequestIdentifierTypeEnum = {
    Internal: 'INTERNAL',
    Xroad: 'XROAD'
} as const;

export type CreatePublisherRequestIdentifierTypeEnum = typeof CreatePublisherRequestIdentifierTypeEnum[keyof typeof CreatePublisherRequestIdentifierTypeEnum];

/**
 * Create Publisher Response
 * @export
 * @interface CreatePublisherResponse
 */
export interface CreatePublisherResponse {
    /**
     * The publisher ID
     * @type {string}
     * @memberof CreatePublisherResponse
     */
    'publisherId': string;
}
/**
 * Create Room
 * @export
 * @interface CreateRoomRequest
 */
export interface CreateRoomRequest {
    /**
     * Identifier of the room
     * @type {string}
     * @memberof CreateRoomRequest
     */
    'identifier': string;
    /**
     * Identifier of the manager of this room
     * @type {string}
     * @memberof CreateRoomRequest
     */
    'managerIdentifier': string;
    /**
     * Default duration in milliseconds after which messages should expire. If set to \'null\', messages never expire.
     * @type {number}
     * @memberof CreateRoomRequest
     */
    'messageExpiration': number;
    /**
     * Default duration in milliseconds for delay between message delivery attempts for subscriptions in PUSH configuration, ignored for PULL. Can be overridden by subscriptions
     * @type {number}
     * @memberof CreateRoomRequest
     */
    'deliveryDelay': number;
    /**
     * Default multiplier by which delivery delay is increased exponentially between delivery attempts. Can be overridden by subscriptions.
     * @type {number}
     * @memberof CreateRoomRequest
     */
    'deliveryDelayMultiplier': number;
    /**
     * Maximum number of delivery attempts for a message in PUSH configuration, ignored for PULL
     * @type {number}
     * @memberof CreateRoomRequest
     */
    'deliveryAttempts': number;
}
/**
 * Create Room Response
 * @export
 * @interface CreateRoomResponse
 */
export interface CreateRoomResponse {
    /**
     * The room unique id
     * @type {string}
     * @memberof CreateRoomResponse
     */
    'roomId'?: string;
}
/**
 * Create Subscription
 * @export
 * @interface CreateSubscriptionRequest
 */
export interface CreateSubscriptionRequest {
    /**
     * Identifies the event type
     * @type {string}
     * @memberof CreateSubscriptionRequest
     */
    'eventType': string;
    /**
     * Identifies the subscriptions
     * @type {string}
     * @memberof CreateSubscriptionRequest
     */
    'identifier': string;
    /**
     * The identifier type
     * @type {string}
     * @memberof CreateSubscriptionRequest
     */
    'identifierType': CreateSubscriptionRequestIdentifierTypeEnum;
    /**
     * Identifies subscription type as either being PULL or PUSH
     * @type {string}
     * @memberof CreateSubscriptionRequest
     */
    'method': CreateSubscriptionRequestMethodEnum;
    /**
     * URL for the callback to push messages. Required for PUSH configuration, ignored for PULL.
     * @type {string}
     * @memberof CreateSubscriptionRequest
     */
    'pushUrl'?: string;
    /**
     * Duration in milliseconds for delay between message delivery attempts. Optional and will override room default value in PUSH configuration, ignored for PULL.
     * @type {number}
     * @memberof CreateSubscriptionRequest
     */
    'deliveryDelay'?: number;
    /**
     * Multiplier by which delivery delay is increased exponentially between delivery attempts. Optional and will override room default value in PUSH configuration, ignored for PULL.
     * @type {number}
     * @memberof CreateSubscriptionRequest
     */
    'deliveryDelayMultiplier'?: number;
    /**
     * Maximum number of delivery attempts for a message in PUSH configuration, ignored for PULL
     * @type {number}
     * @memberof CreateSubscriptionRequest
     */
    'deliveryAttempts'?: number;
}

export const CreateSubscriptionRequestIdentifierTypeEnum = {
    Internal: 'INTERNAL',
    Xroad: 'XROAD'
} as const;

export type CreateSubscriptionRequestIdentifierTypeEnum = typeof CreateSubscriptionRequestIdentifierTypeEnum[keyof typeof CreateSubscriptionRequestIdentifierTypeEnum];
export const CreateSubscriptionRequestMethodEnum = {
    Push: 'PUSH',
    Pull: 'PULL'
} as const;

export type CreateSubscriptionRequestMethodEnum = typeof CreateSubscriptionRequestMethodEnum[keyof typeof CreateSubscriptionRequestMethodEnum];

/**
 * Create Subscription Response
 * @export
 * @interface CreateSubscriptionResponse
 */
export interface CreateSubscriptionResponse {
    /**
     * The subscription id
     * @type {string}
     * @memberof CreateSubscriptionResponse
     */
    'subscriptionId': string;
}
/**
 * Create XRoad Subscription
 * @export
 * @interface CreateXRoadSubscriptionRequest
 */
export interface CreateXRoadSubscriptionRequest {
    /**
     * Identifies the event type
     * @type {string}
     * @memberof CreateXRoadSubscriptionRequest
     */
    'eventType': string;
    /**
     * Identifies subscription type as either being PULL or PUSH
     * @type {string}
     * @memberof CreateXRoadSubscriptionRequest
     */
    'method': CreateXRoadSubscriptionRequestMethodEnum;
    /**
     * URL for the callback to push messages. Required for PUSH configuration, ignored for PULL.
     * @type {string}
     * @memberof CreateXRoadSubscriptionRequest
     */
    'pushUrl'?: string;
    /**
     * Duration in milliseconds for delay between message delivery attempts. Optional and will override room default value in PUSH configuration, ignored for PULL.
     * @type {number}
     * @memberof CreateXRoadSubscriptionRequest
     */
    'deliveryDelay'?: number;
    /**
     * Multiplier by which delivery delay is increased exponentially between delivery attempts. Optional and will override room default value in PUSH configuration, ignored for PULL.
     * @type {number}
     * @memberof CreateXRoadSubscriptionRequest
     */
    'deliveryDelayMultiplier'?: number;
    /**
     * Maximum number of delivery attempts for a message in PUSH configuration, ignored for PULL
     * @type {number}
     * @memberof CreateXRoadSubscriptionRequest
     */
    'deliveryAttempts'?: number;
}

export const CreateXRoadSubscriptionRequestMethodEnum = {
    Push: 'PUSH',
    Pull: 'PULL'
} as const;

export type CreateXRoadSubscriptionRequestMethodEnum = typeof CreateXRoadSubscriptionRequestMethodEnum[keyof typeof CreateXRoadSubscriptionRequestMethodEnum];

/**
 * Status of the message for this event
 * @export
 * @enum {string}
 */

export const DeliveryStatus = {
    Published: 'PUBLISHED',
    Pending: 'PENDING',
    Unconsumed: 'UNCONSUMED',
    Delivered: 'DELIVERED'
} as const;

export type DeliveryStatus = typeof DeliveryStatus[keyof typeof DeliveryStatus];


/**
 * The event details
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * The event ID
     * @type {string}
     * @memberof Event
     */
    'id': string;
    /**
     * The event correlation ID
     * @type {string}
     * @memberof Event
     */
    'correlationId': string;
    /**
     * Identifies when the event was created
     * @type {string}
     * @memberof Event
     */
    'createdAt': string;
}
/**
 * Identifies the delivery attempts history (delivery attempts and successful deliveries)
 * @export
 * @interface EventDelivery
 */
export interface EventDelivery {
    /**
     * Identifies the date and time of delivery attempt
     * @type {string}
     * @memberof EventDelivery
     */
    'publishedAt': string;
    /**
     * Identifies the date and time of successful delivery
     * @type {string}
     * @memberof EventDelivery
     */
    'deliveredAt': string;
}
/**
 * Event Details
 * @export
 * @interface EventDetails
 */
export interface EventDetails {
    /**
     * 
     * @type {Event}
     * @memberof EventDetails
     */
    'event': Event;
    /**
     * 
     * @type {EventType}
     * @memberof EventDetails
     */
    'eventType': EventType;
    /**
     * 
     * @type {EventTypeVersion}
     * @memberof EventDetails
     */
    'eventTypeVersion': EventTypeVersion;
    /**
     * 
     * @type {Publisher}
     * @memberof EventDetails
     */
    'publisher': Publisher;
    /**
     * The subscription details
     * @type {Array<Subscription>}
     * @memberof EventDetails
     */
    'subscriptions': Array<Subscription>;
}
/**
 * The event type details
 * @export
 * @interface EventType
 */
export interface EventType {
    /**
     * The event type ID
     * @type {string}
     * @memberof EventType
     */
    'id': string;
    /**
     * The event type identifier
     * @type {string}
     * @memberof EventType
     */
    'identifier': string;
    /**
     * Identifies when the event type was deleted (from when it\'s inactive and no longer used)
     * @type {string}
     * @memberof EventType
     */
    'deletedAt'?: string;
}
/**
 * The event type version details
 * @export
 * @interface EventTypeVersion
 */
export interface EventTypeVersion {
    /**
     * The event type version ID
     * @type {string}
     * @memberof EventTypeVersion
     */
    'id': string;
    /**
     * Identifies the version of the event type
     * @type {number}
     * @memberof EventTypeVersion
     */
    'versionNo': number;
    /**
     * Identifies the schema use for validating the event payload
     * @type {string}
     * @memberof EventTypeVersion
     */
    'schema': string;
    /**
     * Identifies when the event type version was deleted (from when it\'s inactive and no longer used)
     * @type {string}
     * @memberof EventTypeVersion
     */
    'deletedAt'?: string;
}
/**
 * Event Type View
 * @export
 * @interface EventTypeView
 */
export interface EventTypeView {
    /**
     * The event type ID
     * @type {string}
     * @memberof EventTypeView
     */
    'id': string;
    /**
     * The event type name
     * @type {string}
     * @memberof EventTypeView
     */
    'identifier': string;
    /**
     * Identifies when the event type was created
     * @type {string}
     * @memberof EventTypeView
     */
    'createdAt': string;
    /**
     * Identifies who created the event type
     * @type {string}
     * @memberof EventTypeView
     */
    'createdBy': string;
    /**
     * Identifies the number of versions available for this event type
     * @type {number}
     * @memberof EventTypeView
     */
    'versions'?: number;
}
/**
 * Event view data
 * @export
 * @interface EventView
 */
export interface EventView {
    /**
     * 
     * @type {string}
     * @memberof EventView
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventView
     */
    'correlationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventView
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventView
     */
    'publisherId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventView
     */
    'publisherIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventView
     */
    'eventTypeIdentifier'?: string;
    /**
     * 
     * @type {number}
     * @memberof EventView
     */
    'eventTypeVersionNo'?: number;
}
/**
 * Event view response with paging metadata
 * @export
 * @interface EventsViewResponse
 */
export interface EventsViewResponse {
    /**
     * List of eventsPage
     * @type {Array<EventView>}
     * @memberof EventsViewResponse
     */
    'events': Array<EventView>;
    /**
     * 
     * @type {PagingMetadata}
     * @memberof EventsViewResponse
     */
    'pagingMetadata': PagingMetadata;
}
/**
 * Manager Response
 * @export
 * @interface ManagerResponse
 */
export interface ManagerResponse {
    /**
     * 
     * @type {string}
     * @memberof ManagerResponse
     */
    'id'?: string;
    /**
     * Identifies the manager
     * @type {string}
     * @memberof ManagerResponse
     */
    'identifier': string;
    /**
     * The identifier type
     * @type {string}
     * @memberof ManagerResponse
     */
    'identifierType': ManagerResponseIdentifierTypeEnum;
}

export const ManagerResponseIdentifierTypeEnum = {
    Internal: 'INTERNAL',
    Xroad: 'XROAD'
} as const;

export type ManagerResponseIdentifierTypeEnum = typeof ManagerResponseIdentifierTypeEnum[keyof typeof ManagerResponseIdentifierTypeEnum];

/**
 * Member data
 * @export
 * @interface MemberData
 */
export interface MemberData {
    /**
     * X-Road member subsystem identifier
     * @type {string}
     * @memberof MemberData
     */
    'identifier': string;
    /**
     * X-Road member name
     * @type {string}
     * @memberof MemberData
     */
    'name': string;
    /**
     * X-Road member subsystem code
     * @type {string}
     * @memberof MemberData
     */
    'subsystemCode': string;
    /**
     * X-Road member code
     * @type {string}
     * @memberof MemberData
     */
    'memberCode': string;
    /**
     * X-Road member class
     * @type {string}
     * @memberof MemberData
     */
    'memberClass': string;
    /**
     * 
     * @type {string}
     * @memberof MemberData
     */
    'xroadInstance'?: string;
}
/**
 * Members Response
 * @export
 * @interface MembersResponse
 */
export interface MembersResponse {
    /**
     * List of members
     * @type {Array<MemberData>}
     * @memberof MembersResponse
     */
    'members': Array<MemberData>;
    /**
     * 
     * @type {PagingMetadata}
     * @memberof MembersResponse
     */
    'pagingMetadata': PagingMetadata;
}
/**
 * Modify Room
 * @export
 * @interface ModifyRoomRequest
 */
export interface ModifyRoomRequest {
    /**
     * New identifier for the room
     * @type {string}
     * @memberof ModifyRoomRequest
     */
    'identifier'?: string;
    /**
     * Identifier of the new manager of this room
     * @type {string}
     * @memberof ModifyRoomRequest
     */
    'managerIdentifier'?: string;
    /**
     * Default duration in milliseconds after which messages should expire. If set to \'null\', messages never expire.
     * @type {number}
     * @memberof ModifyRoomRequest
     */
    'messageExpiration': number;
    /**
     * Default duration in milliseconds for delay between message delivery attempts for subscriptions in PUSH configuration, ignored for PULL. Can be overridden by subscriptions
     * @type {number}
     * @memberof ModifyRoomRequest
     */
    'deliveryDelay': number;
    /**
     * Default multiplier by which delivery delay is increased exponentially between delivery attempts. Can be overridden by subscriptions.
     * @type {number}
     * @memberof ModifyRoomRequest
     */
    'deliveryDelayMultiplier': number;
    /**
     * Maximum number of delivery attempts for a message in PUSH configuration, ignored for PULL
     * @type {number}
     * @memberof ModifyRoomRequest
     */
    'deliveryAttempts': number;
}
/**
 * Paginated event types response
 * @export
 * @interface PagedEventTypeViewsResponse
 */
export interface PagedEventTypeViewsResponse {
    /**
     * List of event types
     * @type {Array<EventTypeView>}
     * @memberof PagedEventTypeViewsResponse
     */
    'eventTypes': Array<EventTypeView>;
    /**
     * 
     * @type {PagingMetadata}
     * @memberof PagedEventTypeViewsResponse
     */
    'pagingMetadata': PagingMetadata;
}
/**
 * Paged managers response
 * @export
 * @interface PagedManagersResponse
 */
export interface PagedManagersResponse {
    /**
     * List of managers
     * @type {Array<ManagerResponse>}
     * @memberof PagedManagersResponse
     */
    'managers': Array<ManagerResponse>;
    /**
     * 
     * @type {PagingMetadata}
     * @memberof PagedManagersResponse
     */
    'pagingMetadata': PagingMetadata;
}
/**
 * Paginated publishers response
 * @export
 * @interface PaginatedPublishersResponse
 */
export interface PaginatedPublishersResponse {
    /**
     * List of publishers
     * @type {Array<PublisherViewResponse>}
     * @memberof PaginatedPublishersResponse
     */
    'publishers': Array<PublisherViewResponse>;
    /**
     * 
     * @type {PagingMetadata}
     * @memberof PaginatedPublishersResponse
     */
    'pagingMetadata': PagingMetadata;
}
/**
 * Paginated rooms response
 * @export
 * @interface PaginatedRoomsResponse
 */
export interface PaginatedRoomsResponse {
    /**
     * List of rooms
     * @type {Array<RoomResponse>}
     * @memberof PaginatedRoomsResponse
     */
    'rooms': Array<RoomResponse>;
    /**
     * 
     * @type {PagingMetadata}
     * @memberof PaginatedRoomsResponse
     */
    'pagingMetadata': PagingMetadata;
}
/**
 * Paginated subscription events delivery list
 * @export
 * @interface PaginatedSubscriptionEventDeliveriesList
 */
export interface PaginatedSubscriptionEventDeliveriesList {
    /**
     * List of events with delivery info
     * @type {Array<SubscriptionEventDeliveryItem>}
     * @memberof PaginatedSubscriptionEventDeliveriesList
     */
    'events': Array<SubscriptionEventDeliveryItem>;
    /**
     * 
     * @type {PagingMetadata}
     * @memberof PaginatedSubscriptionEventDeliveriesList
     */
    'pagingMetadata': PagingMetadata;
}
/**
 * Paginated subscriptions list
 * @export
 * @interface PaginatedSubscriptionsList
 */
export interface PaginatedSubscriptionsList {
    /**
     * List of subscriptions
     * @type {Array<SubscriptionListItem>}
     * @memberof PaginatedSubscriptionsList
     */
    'subscriptions': Array<SubscriptionListItem>;
    /**
     * 
     * @type {PagingMetadata}
     * @memberof PaginatedSubscriptionsList
     */
    'pagingMetadata': PagingMetadata;
}
/**
 * Paging Metadata
 * @export
 * @interface PagingMetadata
 */
export interface PagingMetadata {
    /**
     * Number of items on the current page of query results
     * @type {number}
     * @memberof PagingMetadata
     */
    'items': number;
    /**
     * Indicates the maximum number of items for the returned page. 
     * @type {number}
     * @memberof PagingMetadata
     */
    'limit': number;
    /**
     * Offset in pages from the beginning of the query result after filtering and sorting parameters are taken into account.
     * @type {number}
     * @memberof PagingMetadata
     */
    'offset': number;
    /**
     * Total number of items in the query results
     * @type {number}
     * @memberof PagingMetadata
     */
    'total_items': number;
}
/**
 * Paging and sorting input data
 * @export
 * @interface PagingSortingParameters
 */
export interface PagingSortingParameters {
    /**
     * Indicates item property that is to be used as filtering key
     * @type {string}
     * @memberof PagingSortingParameters
     */
    'filterBy'?: string;
    /**
     * Indicates item property that is to be used as sorting key
     * @type {string}
     * @memberof PagingSortingParameters
     */
    'sortBy'?: string;
    /**
     * Used sorting direction. Value \'true\'  indicates descending and \'false\' or omitted parameter indicates ascending direction
     * @type {boolean}
     * @memberof PagingSortingParameters
     */
    'desc'?: boolean;
    /**
     * Indicates the maximum number of items for the returned page. If parameter is omitted, then the default amount of 25 is returned.
     * @type {number}
     * @memberof PagingSortingParameters
     */
    'limit'?: number;
    /**
     * Offset in pages from the beginning of the query result after filtering and sorting parameters are taken into account. If the parameter omitted or the value 0 (zero) is given, the first page is returned.
     * @type {number}
     * @memberof PagingSortingParameters
     */
    'offset'?: number;
}
/**
 * The publisher details
 * @export
 * @interface Publisher
 */
export interface Publisher {
    /**
     * The publisher ID
     * @type {string}
     * @memberof Publisher
     */
    'id': string;
    /**
     * The publisher identifier
     * @type {string}
     * @memberof Publisher
     */
    'identifier': string;
    /**
     * The publisher identifier type
     * @type {string}
     * @memberof Publisher
     */
    'identifierType': string;
    /**
     * Identifies when the publisher was deleted (from when it\'s inactive and no longer used)
     * @type {string}
     * @memberof Publisher
     */
    'deletedAt'?: string;
}
/**
 * Publisher Constraint View
 * @export
 * @interface PublisherConstraintView
 */
export interface PublisherConstraintView {
    /**
     * The event type ID
     * @type {string}
     * @memberof PublisherConstraintView
     */
    'eventTypeId': string;
    /**
     * The event type name
     * @type {string}
     * @memberof PublisherConstraintView
     */
    'eventIdentifier': string;
    /**
     * Identifies when the constraint was created
     * @type {string}
     * @memberof PublisherConstraintView
     */
    'createdAt': string;
}
/**
 * Publisher View Response
 * @export
 * @interface PublisherViewResponse
 */
export interface PublisherViewResponse {
    /**
     * The publisher ID
     * @type {string}
     * @memberof PublisherViewResponse
     */
    'id': string;
    /**
     * The publisher identifier
     * @type {string}
     * @memberof PublisherViewResponse
     */
    'identifier': string;
    /**
     * The publisher type
     * @type {string}
     * @memberof PublisherViewResponse
     */
    'identifierType': PublisherViewResponseIdentifierTypeEnum;
    /**
     * Identifies when the publisher was created
     * @type {string}
     * @memberof PublisherViewResponse
     */
    'createdAt': string;
    /**
     * Identifies who created the publisher
     * @type {string}
     * @memberof PublisherViewResponse
     */
    'createdBy': string;
    /**
     * The publisher constraints
     * @type {Array<PublisherConstraintView>}
     * @memberof PublisherViewResponse
     */
    'constraints'?: Array<PublisherConstraintView>;
}

export const PublisherViewResponseIdentifierTypeEnum = {
    Xroad: 'XROAD',
    Internal: 'INTERNAL'
} as const;

export type PublisherViewResponseIdentifierTypeEnum = typeof PublisherViewResponseIdentifierTypeEnum[keyof typeof PublisherViewResponseIdentifierTypeEnum];

/**
 * Detailed room information
 * @export
 * @interface RoomDetailedResponse
 */
export interface RoomDetailedResponse {
    /**
     * Identifier of the room
     * @type {string}
     * @memberof RoomDetailedResponse
     */
    'identifier': string;
    /**
     * Identifier of the manager of this room
     * @type {string}
     * @memberof RoomDetailedResponse
     */
    'managerIdentifier': string;
    /**
     * Default duration in milliseconds after which messages should expire. If set to \'null\', messages never expire.
     * @type {number}
     * @memberof RoomDetailedResponse
     */
    'messageExpiration': number;
    /**
     * Default duration in milliseconds for delay between message delivery attempts for subscriptions in PUSH configuration, ignored for PULL. Can be overridden by subscriptions
     * @type {number}
     * @memberof RoomDetailedResponse
     */
    'deliveryDelay': number;
    /**
     * Default multiplier by which delivery delay is increased exponentially between delivery attempts. Can be overridden by subscriptions.
     * @type {number}
     * @memberof RoomDetailedResponse
     */
    'deliveryDelayMultiplier': number;
    /**
     * Maximum number of delivery attempts for a message in PUSH configuration, ignored for PULL
     * @type {number}
     * @memberof RoomDetailedResponse
     */
    'deliveryAttempts': number;
}
/**
 * Detailed room information
 * @export
 * @interface RoomFullResponse
 */
export interface RoomFullResponse {
    /**
     * Identifier of the room
     * @type {string}
     * @memberof RoomFullResponse
     */
    'identifier': string;
    /**
     * Identifier of the manager of this room
     * @type {string}
     * @memberof RoomFullResponse
     */
    'managerIdentifier': string;
    /**
     * Default duration in milliseconds after which messages should expire. If set to \'null\', messages never expire.
     * @type {number}
     * @memberof RoomFullResponse
     */
    'messageExpiration': number;
    /**
     * Default duration in milliseconds for delay between message delivery attempts for subscriptions in PUSH configuration, ignored for PULL. Can be overridden by subscriptions
     * @type {number}
     * @memberof RoomFullResponse
     */
    'deliveryDelay': number;
    /**
     * Default multiplier by which delivery delay is increased exponentially between delivery attempts. Can be overridden by subscriptions.
     * @type {number}
     * @memberof RoomFullResponse
     */
    'deliveryDelayMultiplier': number;
    /**
     * Maximum number of delivery attempts for a message in PUSH configuration, ignored for PULL
     * @type {number}
     * @memberof RoomFullResponse
     */
    'deliveryAttempts': number;
    /**
     * Identifies when the room was created
     * @type {string}
     * @memberof RoomFullResponse
     */
    'createdAt': string;
    /**
     * Identifies who created the room
     * @type {string}
     * @memberof RoomFullResponse
     */
    'createdBy': string;
}
/**
 * Room main information
 * @export
 * @interface RoomResponse
 */
export interface RoomResponse {
    /**
     * Identifier of the room
     * @type {string}
     * @memberof RoomResponse
     */
    'identifier': string;
    /**
     * Identifier of the manager of this room
     * @type {string}
     * @memberof RoomResponse
     */
    'managerIdentifier': string;
}
/**
 * Subscription status to be set
 * @export
 * @enum {string}
 */

export const Status = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Rejected: 'REJECTED',
    Terminated: 'TERMINATED'
} as const;

export type Status = typeof Status[keyof typeof Status];


/**
 * The subscription details
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * The subscription ID
     * @type {string}
     * @memberof Subscription
     */
    'id': string;
    /**
     * The subscription identifier
     * @type {string}
     * @memberof Subscription
     */
    'identifier': string;
    /**
     * The subscription identifier type
     * @type {string}
     * @memberof Subscription
     */
    'identifierType': string;
    /**
     * The subscription status
     * @type {string}
     * @memberof Subscription
     */
    'status': string;
    /**
     * Identifies if the event is delivered to the subscription
     * @type {boolean}
     * @memberof Subscription
     */
    'isDelivered': boolean;
    /**
     * Identifies the total number of delivery attempts
     * @type {number}
     * @memberof Subscription
     */
    'deliveryAttempts': number;
    /**
     * Identifies the delivery attempts history (delivery attempts and successful deliveries)
     * @type {Array<EventDelivery>}
     * @memberof Subscription
     */
    'deliveries': Array<EventDelivery>;
    /**
     * Identifies when the subscription was deleted (from when it\'s inactive and no longer used)
     * @type {string}
     * @memberof Subscription
     */
    'deletedAt': string;
}
/**
 * Subscription event delivery item
 * @export
 * @interface SubscriptionEventDeliveryItem
 */
export interface SubscriptionEventDeliveryItem {
    /**
     * Event ID
     * @type {string}
     * @memberof SubscriptionEventDeliveryItem
     */
    'eventId'?: string;
    /**
     * Describes the subscription\'s identifier type
     * @type {string}
     * @memberof SubscriptionEventDeliveryItem
     */
    'eventTypeIdentifier'?: string;
    /**
     * 
     * @type {DeliveryStatus}
     * @memberof SubscriptionEventDeliveryItem
     */
    'deliveryStatus': DeliveryStatus;
    /**
     * Identifies how many times the message has been (or was) attempted to deliver
     * @type {number}
     * @memberof SubscriptionEventDeliveryItem
     */
    'deliveryAttempts': number;
    /**
     * When the event was created
     * @type {string}
     * @memberof SubscriptionEventDeliveryItem
     */
    'createdAt': string;
}


/**
 * Subscriptions list item
 * @export
 * @interface SubscriptionListItem
 */
export interface SubscriptionListItem {
    /**
     * Identifies the event type
     * @type {string}
     * @memberof SubscriptionListItem
     */
    'id'?: string;
    /**
     * Describes the subscription\'s identifier
     * @type {string}
     * @memberof SubscriptionListItem
     */
    'identifier'?: string;
    /**
     * Describes the subscription\'s identifier type
     * @type {string}
     * @memberof SubscriptionListItem
     */
    'eventTypeIdentifier'?: string;
    /**
     * Identifies subscription type as either being PULL or PUSH
     * @type {string}
     * @memberof SubscriptionListItem
     */
    'method': SubscriptionListItemMethodEnum;
    /**
     * URL for the callback to push messages. Required for PUSH configuration, ignored for PULL.
     * @type {string}
     * @memberof SubscriptionListItem
     */
    'pushUrl'?: string;
    /**
     * 
     * @type {Status}
     * @memberof SubscriptionListItem
     */
    'status'?: Status;
    /**
     * When the subscription was created
     * @type {string}
     * @memberof SubscriptionListItem
     */
    'createdAt': string;
}

export const SubscriptionListItemMethodEnum = {
    Push: 'PUSH',
    Pull: 'PULL'
} as const;

export type SubscriptionListItemMethodEnum = typeof SubscriptionListItemMethodEnum[keyof typeof SubscriptionListItemMethodEnum];

/**
 * Update Event Type Version
 * @export
 * @interface UpdateEventTypeVersion
 */
export interface UpdateEventTypeVersion {
    /**
     * The version number
     * @type {number}
     * @memberof UpdateEventTypeVersion
     */
    'versionNo': number;
    /**
     * The version json schema
     * @type {string}
     * @memberof UpdateEventTypeVersion
     */
    'schema': string;
}
/**
 * Update Publisher Request
 * @export
 * @interface UpdatePublisherRequest
 */
export interface UpdatePublisherRequest {
    /**
     * Identifies the event types for the publisher
     * @type {Array<string>}
     * @memberof UpdatePublisherRequest
     */
    'eventTypes': Array<string>;
}
/**
 * Approve or reject a pending subscription
 * @export
 * @interface UpdateSubscriptionStatusRequest
 */
export interface UpdateSubscriptionStatusRequest {
    /**
     * 
     * @type {Status}
     * @memberof UpdateSubscriptionStatusRequest
     */
    'status': Status;
}



/**
 * EventApi - axios parameter creator
 * @export
 */
export const EventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get event details for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventId The event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDetailsAsAdministrator: async (memberId: string, roomId: string, eventId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('getEventDetailsAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getEventDetailsAsAdministrator', 'roomId', roomId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventDetailsAsAdministrator', 'eventId', eventId)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}/events/{eventId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get event details for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventId The event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDetailsAsManager: async (roomId: string, eventId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getEventDetailsAsManager', 'roomId', roomId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventDetailsAsManager', 'eventId', eventId)
            const localVarPath = `/api/rooms/{roomId}/events/{eventId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get event details for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventId The event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDetailsViaXRoad: async (memberId: string, roomId: string, eventId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('getEventDetailsViaXRoad', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getEventDetailsViaXRoad', 'roomId', roomId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('getEventDetailsViaXRoad', 'eventId', eventId)
            const localVarPath = `/rooms/{memberId}/{roomId}/events/{eventId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get eventsPage view for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} from 
         * @param {string} to 
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [publisherId] 
         * @param {string} [publisherIdentifier] 
         * @param {string} [eventTypeIdentifier] 
         * @param {number} [eventTypeVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsViewAsAdministrator: async (memberId: string, roomId: string, from: string, to: string, pagingSortingParameters: PagingSortingParameters, publisherId?: string, publisherIdentifier?: string, eventTypeIdentifier?: string, eventTypeVersion?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('getEventsViewAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getEventsViewAsAdministrator', 'roomId', roomId)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getEventsViewAsAdministrator', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getEventsViewAsAdministrator', 'to', to)
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('getEventsViewAsAdministrator', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}/events`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (publisherId !== undefined) {
                localVarQueryParameter['publisherId'] = publisherId;
            }

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }

            if (publisherIdentifier !== undefined) {
                localVarQueryParameter['publisherIdentifier'] = publisherIdentifier;
            }

            if (eventTypeIdentifier !== undefined) {
                localVarQueryParameter['eventTypeIdentifier'] = eventTypeIdentifier;
            }

            if (eventTypeVersion !== undefined) {
                localVarQueryParameter['eventTypeVersion'] = eventTypeVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get eventsPage view  for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} from 
         * @param {string} to 
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [publisherId] 
         * @param {string} [publisherIdentifier] 
         * @param {string} [eventTypeIdentifier] 
         * @param {number} [eventTypeVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsViewAsManager: async (roomId: string, from: string, to: string, pagingSortingParameters: PagingSortingParameters, publisherId?: string, publisherIdentifier?: string, eventTypeIdentifier?: string, eventTypeVersion?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getEventsViewAsManager', 'roomId', roomId)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getEventsViewAsManager', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getEventsViewAsManager', 'to', to)
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('getEventsViewAsManager', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/api/rooms/{roomId}/events`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (publisherId !== undefined) {
                localVarQueryParameter['publisherId'] = publisherId;
            }

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }

            if (publisherIdentifier !== undefined) {
                localVarQueryParameter['publisherIdentifier'] = publisherIdentifier;
            }

            if (eventTypeIdentifier !== undefined) {
                localVarQueryParameter['eventTypeIdentifier'] = eventTypeIdentifier;
            }

            if (eventTypeVersion !== undefined) {
                localVarQueryParameter['eventTypeVersion'] = eventTypeVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get eventsPage view for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} from 
         * @param {string} to 
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [publisherId] 
         * @param {string} [publisherIdentifier] 
         * @param {string} [eventTypeIdentifier] 
         * @param {number} [eventTypeVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsViewViaXRoad: async (memberId: string, roomId: string, from: string, to: string, pagingSortingParameters: PagingSortingParameters, publisherId?: string, publisherIdentifier?: string, eventTypeIdentifier?: string, eventTypeVersion?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('getEventsViewViaXRoad', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getEventsViewViaXRoad', 'roomId', roomId)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getEventsViewViaXRoad', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getEventsViewViaXRoad', 'to', to)
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('getEventsViewViaXRoad', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/rooms/{memberId}/{roomId}/events`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (publisherId !== undefined) {
                localVarQueryParameter['publisherId'] = publisherId;
            }

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }

            if (publisherIdentifier !== undefined) {
                localVarQueryParameter['publisherIdentifier'] = publisherIdentifier;
            }

            if (eventTypeIdentifier !== undefined) {
                localVarQueryParameter['eventTypeIdentifier'] = eventTypeIdentifier;
            }

            if (eventTypeVersion !== undefined) {
                localVarQueryParameter['eventTypeVersion'] = eventTypeVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get event details for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventId The event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventDetailsAsAdministrator(memberId: string, roomId: string, eventId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventDetailsAsAdministrator(memberId, roomId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get event details for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventId The event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventDetailsAsManager(roomId: string, eventId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventDetailsAsManager(roomId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get event details for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventId The event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventDetailsViaXRoad(memberId: string, roomId: string, eventId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventDetailsViaXRoad(memberId, roomId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get eventsPage view for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} from 
         * @param {string} to 
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [publisherId] 
         * @param {string} [publisherIdentifier] 
         * @param {string} [eventTypeIdentifier] 
         * @param {number} [eventTypeVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventsViewAsAdministrator(memberId: string, roomId: string, from: string, to: string, pagingSortingParameters: PagingSortingParameters, publisherId?: string, publisherIdentifier?: string, eventTypeIdentifier?: string, eventTypeVersion?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsViewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventsViewAsAdministrator(memberId, roomId, from, to, pagingSortingParameters, publisherId, publisherIdentifier, eventTypeIdentifier, eventTypeVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get eventsPage view  for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} from 
         * @param {string} to 
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [publisherId] 
         * @param {string} [publisherIdentifier] 
         * @param {string} [eventTypeIdentifier] 
         * @param {number} [eventTypeVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventsViewAsManager(roomId: string, from: string, to: string, pagingSortingParameters: PagingSortingParameters, publisherId?: string, publisherIdentifier?: string, eventTypeIdentifier?: string, eventTypeVersion?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsViewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventsViewAsManager(roomId, from, to, pagingSortingParameters, publisherId, publisherIdentifier, eventTypeIdentifier, eventTypeVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get eventsPage view for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} from 
         * @param {string} to 
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [publisherId] 
         * @param {string} [publisherIdentifier] 
         * @param {string} [eventTypeIdentifier] 
         * @param {number} [eventTypeVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventsViewViaXRoad(memberId: string, roomId: string, from: string, to: string, pagingSortingParameters: PagingSortingParameters, publisherId?: string, publisherIdentifier?: string, eventTypeIdentifier?: string, eventTypeVersion?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsViewResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventsViewViaXRoad(memberId, roomId, from, to, pagingSortingParameters, publisherId, publisherIdentifier, eventTypeIdentifier, eventTypeVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventApiFp(configuration)
    return {
        /**
         * 
         * @summary Get event details for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventId The event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDetailsAsAdministrator(memberId: string, roomId: string, eventId: string, options?: any): AxiosPromise<EventDetails> {
            return localVarFp.getEventDetailsAsAdministrator(memberId, roomId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get event details for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventId The event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDetailsAsManager(roomId: string, eventId: string, options?: any): AxiosPromise<EventDetails> {
            return localVarFp.getEventDetailsAsManager(roomId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get event details for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventId The event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventDetailsViaXRoad(memberId: string, roomId: string, eventId: string, options?: any): AxiosPromise<EventDetails> {
            return localVarFp.getEventDetailsViaXRoad(memberId, roomId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get eventsPage view for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} from 
         * @param {string} to 
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [publisherId] 
         * @param {string} [publisherIdentifier] 
         * @param {string} [eventTypeIdentifier] 
         * @param {number} [eventTypeVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsViewAsAdministrator(memberId: string, roomId: string, from: string, to: string, pagingSortingParameters: PagingSortingParameters, publisherId?: string, publisherIdentifier?: string, eventTypeIdentifier?: string, eventTypeVersion?: number, options?: any): AxiosPromise<EventsViewResponse> {
            return localVarFp.getEventsViewAsAdministrator(memberId, roomId, from, to, pagingSortingParameters, publisherId, publisherIdentifier, eventTypeIdentifier, eventTypeVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get eventsPage view  for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} from 
         * @param {string} to 
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [publisherId] 
         * @param {string} [publisherIdentifier] 
         * @param {string} [eventTypeIdentifier] 
         * @param {number} [eventTypeVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsViewAsManager(roomId: string, from: string, to: string, pagingSortingParameters: PagingSortingParameters, publisherId?: string, publisherIdentifier?: string, eventTypeIdentifier?: string, eventTypeVersion?: number, options?: any): AxiosPromise<EventsViewResponse> {
            return localVarFp.getEventsViewAsManager(roomId, from, to, pagingSortingParameters, publisherId, publisherIdentifier, eventTypeIdentifier, eventTypeVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get eventsPage view for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} from 
         * @param {string} to 
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [publisherId] 
         * @param {string} [publisherIdentifier] 
         * @param {string} [eventTypeIdentifier] 
         * @param {number} [eventTypeVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsViewViaXRoad(memberId: string, roomId: string, from: string, to: string, pagingSortingParameters: PagingSortingParameters, publisherId?: string, publisherIdentifier?: string, eventTypeIdentifier?: string, eventTypeVersion?: number, options?: any): AxiosPromise<EventsViewResponse> {
            return localVarFp.getEventsViewViaXRoad(memberId, roomId, from, to, pagingSortingParameters, publisherId, publisherIdentifier, eventTypeIdentifier, eventTypeVersion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI {
    /**
     * 
     * @summary Get event details for PubSub administrators
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} eventId The event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventDetailsAsAdministrator(memberId: string, roomId: string, eventId: string, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).getEventDetailsAsAdministrator(memberId, roomId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get event details for PubSub managers
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} eventId The event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventDetailsAsManager(roomId: string, eventId: string, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).getEventDetailsAsManager(roomId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get event details for PubSub managers accessing via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} eventId The event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventDetailsViaXRoad(memberId: string, roomId: string, eventId: string, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).getEventDetailsViaXRoad(memberId, roomId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get eventsPage view for PubSub administrators
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} from 
     * @param {string} to 
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {string} [publisherId] 
     * @param {string} [publisherIdentifier] 
     * @param {string} [eventTypeIdentifier] 
     * @param {number} [eventTypeVersion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventsViewAsAdministrator(memberId: string, roomId: string, from: string, to: string, pagingSortingParameters: PagingSortingParameters, publisherId?: string, publisherIdentifier?: string, eventTypeIdentifier?: string, eventTypeVersion?: number, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).getEventsViewAsAdministrator(memberId, roomId, from, to, pagingSortingParameters, publisherId, publisherIdentifier, eventTypeIdentifier, eventTypeVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get eventsPage view  for PubSub managers
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} from 
     * @param {string} to 
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {string} [publisherId] 
     * @param {string} [publisherIdentifier] 
     * @param {string} [eventTypeIdentifier] 
     * @param {number} [eventTypeVersion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventsViewAsManager(roomId: string, from: string, to: string, pagingSortingParameters: PagingSortingParameters, publisherId?: string, publisherIdentifier?: string, eventTypeIdentifier?: string, eventTypeVersion?: number, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).getEventsViewAsManager(roomId, from, to, pagingSortingParameters, publisherId, publisherIdentifier, eventTypeIdentifier, eventTypeVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get eventsPage view for PubSub managers accessing via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} from 
     * @param {string} to 
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {string} [publisherId] 
     * @param {string} [publisherIdentifier] 
     * @param {string} [eventTypeIdentifier] 
     * @param {number} [eventTypeVersion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public getEventsViewViaXRoad(memberId: string, roomId: string, from: string, to: string, pagingSortingParameters: PagingSortingParameters, publisherId?: string, publisherIdentifier?: string, eventTypeIdentifier?: string, eventTypeVersion?: number, options?: AxiosRequestConfig) {
        return EventApiFp(this.configuration).getEventsViewViaXRoad(memberId, roomId, from, to, pagingSortingParameters, publisherId, publisherIdentifier, eventTypeIdentifier, eventTypeVersion, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventTypeVersionsApi - axios parameter creator
 * @export
 */
export const EventTypeVersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates versions for an event type for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {CreateEventTypeVersion} createEventTypeVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventTypeVersionAsAdministrator: async (memberId: string, roomId: string, eventType: string, createEventTypeVersion: CreateEventTypeVersion, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('createEventTypeVersionAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('createEventTypeVersionAsAdministrator', 'roomId', roomId)
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('createEventTypeVersionAsAdministrator', 'eventType', eventType)
            // verify required parameter 'createEventTypeVersion' is not null or undefined
            assertParamExists('createEventTypeVersionAsAdministrator', 'createEventTypeVersion', createEventTypeVersion)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}/event-types/{eventType}/versions`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventTypeVersion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates versions for an event type for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {CreateEventTypeVersion} createEventTypeVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventTypeVersionAsManager: async (roomId: string, eventType: string, createEventTypeVersion: CreateEventTypeVersion, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('createEventTypeVersionAsManager', 'roomId', roomId)
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('createEventTypeVersionAsManager', 'eventType', eventType)
            // verify required parameter 'createEventTypeVersion' is not null or undefined
            assertParamExists('createEventTypeVersionAsManager', 'createEventTypeVersion', createEventTypeVersion)
            const localVarPath = `/api/rooms/{roomId}/event-types/{eventType}/versions`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventTypeVersion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates versions for an event type for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {CreateEventTypeVersion} createEventTypeVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventTypeVersionViaXRoad: async (memberId: string, roomId: string, eventType: string, createEventTypeVersion: CreateEventTypeVersion, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('createEventTypeVersionViaXRoad', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('createEventTypeVersionViaXRoad', 'roomId', roomId)
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('createEventTypeVersionViaXRoad', 'eventType', eventType)
            // verify required parameter 'createEventTypeVersion' is not null or undefined
            assertParamExists('createEventTypeVersionViaXRoad', 'createEventTypeVersion', createEventTypeVersion)
            const localVarPath = `/rooms/{memberId}/{roomId}/event-types/{eventType}/versions`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventTypeVersion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an event type version for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {number} version The version of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventTypeVersionAsAdministrator: async (memberId: string, roomId: string, eventType: string, version: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('deleteEventTypeVersionAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('deleteEventTypeVersionAsAdministrator', 'roomId', roomId)
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('deleteEventTypeVersionAsAdministrator', 'eventType', eventType)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('deleteEventTypeVersionAsAdministrator', 'version', version)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}/event-types/{eventType}/versions/{version}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an event type version for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {number} version The version of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventTypeVersionAsManager: async (roomId: string, eventType: string, version: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('deleteEventTypeVersionAsManager', 'roomId', roomId)
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('deleteEventTypeVersionAsManager', 'eventType', eventType)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('deleteEventTypeVersionAsManager', 'version', version)
            const localVarPath = `/api/rooms/{roomId}/event-types/{eventType}/versions/{version}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an event type version for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {number} version The version of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventTypeVersionViaXRoad: async (memberId: string, roomId: string, eventType: string, version: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('deleteEventTypeVersionViaXRoad', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('deleteEventTypeVersionViaXRoad', 'roomId', roomId)
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('deleteEventTypeVersionViaXRoad', 'eventType', eventType)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('deleteEventTypeVersionViaXRoad', 'version', version)
            const localVarPath = `/rooms/{memberId}/{roomId}/event-types/{eventType}/versions/{version}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all versions for an event type for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTypeVersionsAsAdministrator: async (memberId: string, roomId: string, eventType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('getEventTypeVersionsAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getEventTypeVersionsAsAdministrator', 'roomId', roomId)
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('getEventTypeVersionsAsAdministrator', 'eventType', eventType)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}/event-types/{eventType}/versions`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all versions for an event type for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTypeVersionsAsManager: async (roomId: string, eventType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getEventTypeVersionsAsManager', 'roomId', roomId)
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('getEventTypeVersionsAsManager', 'eventType', eventType)
            const localVarPath = `/api/rooms/{roomId}/event-types/{eventType}/versions`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all versions for an event type for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTypeVersionsViaXRoad: async (memberId: string, roomId: string, eventType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('getEventTypeVersionsViaXRoad', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getEventTypeVersionsViaXRoad', 'roomId', roomId)
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('getEventTypeVersionsViaXRoad', 'eventType', eventType)
            const localVarPath = `/rooms/{memberId}/{roomId}/event-types/{eventType}/versions`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates versions for an event type for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {UpdateEventTypeVersion} updateEventTypeVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventTypeVersionAsAdministrator: async (memberId: string, roomId: string, eventType: string, updateEventTypeVersion: UpdateEventTypeVersion, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('updateEventTypeVersionAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('updateEventTypeVersionAsAdministrator', 'roomId', roomId)
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('updateEventTypeVersionAsAdministrator', 'eventType', eventType)
            // verify required parameter 'updateEventTypeVersion' is not null or undefined
            assertParamExists('updateEventTypeVersionAsAdministrator', 'updateEventTypeVersion', updateEventTypeVersion)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}/event-types/{eventType}/versions`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventTypeVersion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates versions for an event type for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {UpdateEventTypeVersion} updateEventTypeVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventTypeVersionAsManager: async (roomId: string, eventType: string, updateEventTypeVersion: UpdateEventTypeVersion, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('updateEventTypeVersionAsManager', 'roomId', roomId)
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('updateEventTypeVersionAsManager', 'eventType', eventType)
            // verify required parameter 'updateEventTypeVersion' is not null or undefined
            assertParamExists('updateEventTypeVersionAsManager', 'updateEventTypeVersion', updateEventTypeVersion)
            const localVarPath = `/api/rooms/{roomId}/event-types/{eventType}/versions`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventTypeVersion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates versions for an event type for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {UpdateEventTypeVersion} updateEventTypeVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventTypeVersionViaXRoad: async (memberId: string, roomId: string, eventType: string, updateEventTypeVersion: UpdateEventTypeVersion, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('updateEventTypeVersionViaXRoad', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('updateEventTypeVersionViaXRoad', 'roomId', roomId)
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('updateEventTypeVersionViaXRoad', 'eventType', eventType)
            // verify required parameter 'updateEventTypeVersion' is not null or undefined
            assertParamExists('updateEventTypeVersionViaXRoad', 'updateEventTypeVersion', updateEventTypeVersion)
            const localVarPath = `/rooms/{memberId}/{roomId}/event-types/{eventType}/versions`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEventTypeVersion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventTypeVersionsApi - functional programming interface
 * @export
 */
export const EventTypeVersionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventTypeVersionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates versions for an event type for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {CreateEventTypeVersion} createEventTypeVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventTypeVersionAsAdministrator(memberId: string, roomId: string, eventType: string, createEventTypeVersion: CreateEventTypeVersion, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventTypeVersionAsAdministrator(memberId, roomId, eventType, createEventTypeVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates versions for an event type for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {CreateEventTypeVersion} createEventTypeVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventTypeVersionAsManager(roomId: string, eventType: string, createEventTypeVersion: CreateEventTypeVersion, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventTypeVersionAsManager(roomId, eventType, createEventTypeVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates versions for an event type for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {CreateEventTypeVersion} createEventTypeVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventTypeVersionViaXRoad(memberId: string, roomId: string, eventType: string, createEventTypeVersion: CreateEventTypeVersion, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventTypeVersionViaXRoad(memberId, roomId, eventType, createEventTypeVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes an event type version for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {number} version The version of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventTypeVersionAsAdministrator(memberId: string, roomId: string, eventType: string, version: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventTypeVersionAsAdministrator(memberId, roomId, eventType, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes an event type version for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {number} version The version of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventTypeVersionAsManager(roomId: string, eventType: string, version: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventTypeVersionAsManager(roomId, eventType, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes an event type version for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {number} version The version of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventTypeVersionViaXRoad(memberId: string, roomId: string, eventType: string, version: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventTypeVersionViaXRoad(memberId, roomId, eventType, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists all versions for an event type for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventTypeVersionsAsAdministrator(memberId: string, roomId: string, eventType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventTypeVersion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventTypeVersionsAsAdministrator(memberId, roomId, eventType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists all versions for an event type for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventTypeVersionsAsManager(roomId: string, eventType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventTypeVersion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventTypeVersionsAsManager(roomId, eventType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists all versions for an event type for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventTypeVersionsViaXRoad(memberId: string, roomId: string, eventType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventTypeVersion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventTypeVersionsViaXRoad(memberId, roomId, eventType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates versions for an event type for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {UpdateEventTypeVersion} updateEventTypeVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventTypeVersionAsAdministrator(memberId: string, roomId: string, eventType: string, updateEventTypeVersion: UpdateEventTypeVersion, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventTypeVersionAsAdministrator(memberId, roomId, eventType, updateEventTypeVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates versions for an event type for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {UpdateEventTypeVersion} updateEventTypeVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventTypeVersionAsManager(roomId: string, eventType: string, updateEventTypeVersion: UpdateEventTypeVersion, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventTypeVersionAsManager(roomId, eventType, updateEventTypeVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates versions for an event type for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {UpdateEventTypeVersion} updateEventTypeVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEventTypeVersionViaXRoad(memberId: string, roomId: string, eventType: string, updateEventTypeVersion: UpdateEventTypeVersion, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEventTypeVersionViaXRoad(memberId, roomId, eventType, updateEventTypeVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventTypeVersionsApi - factory interface
 * @export
 */
export const EventTypeVersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventTypeVersionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates versions for an event type for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {CreateEventTypeVersion} createEventTypeVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventTypeVersionAsAdministrator(memberId: string, roomId: string, eventType: string, createEventTypeVersion: CreateEventTypeVersion, options?: any): AxiosPromise<void> {
            return localVarFp.createEventTypeVersionAsAdministrator(memberId, roomId, eventType, createEventTypeVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates versions for an event type for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {CreateEventTypeVersion} createEventTypeVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventTypeVersionAsManager(roomId: string, eventType: string, createEventTypeVersion: CreateEventTypeVersion, options?: any): AxiosPromise<void> {
            return localVarFp.createEventTypeVersionAsManager(roomId, eventType, createEventTypeVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates versions for an event type for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {CreateEventTypeVersion} createEventTypeVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventTypeVersionViaXRoad(memberId: string, roomId: string, eventType: string, createEventTypeVersion: CreateEventTypeVersion, options?: any): AxiosPromise<void> {
            return localVarFp.createEventTypeVersionViaXRoad(memberId, roomId, eventType, createEventTypeVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an event type version for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {number} version The version of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventTypeVersionAsAdministrator(memberId: string, roomId: string, eventType: string, version: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEventTypeVersionAsAdministrator(memberId, roomId, eventType, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an event type version for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {number} version The version of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventTypeVersionAsManager(roomId: string, eventType: string, version: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEventTypeVersionAsManager(roomId, eventType, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an event type version for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {number} version The version of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventTypeVersionViaXRoad(memberId: string, roomId: string, eventType: string, version: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEventTypeVersionViaXRoad(memberId, roomId, eventType, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all versions for an event type for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTypeVersionsAsAdministrator(memberId: string, roomId: string, eventType: string, options?: any): AxiosPromise<Array<EventTypeVersion>> {
            return localVarFp.getEventTypeVersionsAsAdministrator(memberId, roomId, eventType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all versions for an event type for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTypeVersionsAsManager(roomId: string, eventType: string, options?: any): AxiosPromise<Array<EventTypeVersion>> {
            return localVarFp.getEventTypeVersionsAsManager(roomId, eventType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all versions for an event type for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTypeVersionsViaXRoad(memberId: string, roomId: string, eventType: string, options?: any): AxiosPromise<Array<EventTypeVersion>> {
            return localVarFp.getEventTypeVersionsViaXRoad(memberId, roomId, eventType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates versions for an event type for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {UpdateEventTypeVersion} updateEventTypeVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventTypeVersionAsAdministrator(memberId: string, roomId: string, eventType: string, updateEventTypeVersion: UpdateEventTypeVersion, options?: any): AxiosPromise<void> {
            return localVarFp.updateEventTypeVersionAsAdministrator(memberId, roomId, eventType, updateEventTypeVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates versions for an event type for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {UpdateEventTypeVersion} updateEventTypeVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventTypeVersionAsManager(roomId: string, eventType: string, updateEventTypeVersion: UpdateEventTypeVersion, options?: any): AxiosPromise<void> {
            return localVarFp.updateEventTypeVersionAsManager(roomId, eventType, updateEventTypeVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates versions for an event type for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {UpdateEventTypeVersion} updateEventTypeVersion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEventTypeVersionViaXRoad(memberId: string, roomId: string, eventType: string, updateEventTypeVersion: UpdateEventTypeVersion, options?: any): AxiosPromise<void> {
            return localVarFp.updateEventTypeVersionViaXRoad(memberId, roomId, eventType, updateEventTypeVersion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventTypeVersionsApi - object-oriented interface
 * @export
 * @class EventTypeVersionsApi
 * @extends {BaseAPI}
 */
export class EventTypeVersionsApi extends BaseAPI {
    /**
     * 
     * @summary Creates versions for an event type for PubSub administrators
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} eventType The identifier of the event type
     * @param {CreateEventTypeVersion} createEventTypeVersion 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypeVersionsApi
     */
    public createEventTypeVersionAsAdministrator(memberId: string, roomId: string, eventType: string, createEventTypeVersion: CreateEventTypeVersion, options?: AxiosRequestConfig) {
        return EventTypeVersionsApiFp(this.configuration).createEventTypeVersionAsAdministrator(memberId, roomId, eventType, createEventTypeVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates versions for an event type for PubSub managers
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} eventType The identifier of the event type
     * @param {CreateEventTypeVersion} createEventTypeVersion 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypeVersionsApi
     */
    public createEventTypeVersionAsManager(roomId: string, eventType: string, createEventTypeVersion: CreateEventTypeVersion, options?: AxiosRequestConfig) {
        return EventTypeVersionsApiFp(this.configuration).createEventTypeVersionAsManager(roomId, eventType, createEventTypeVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates versions for an event type for PubSub managers accessing via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} eventType The identifier of the event type
     * @param {CreateEventTypeVersion} createEventTypeVersion 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypeVersionsApi
     */
    public createEventTypeVersionViaXRoad(memberId: string, roomId: string, eventType: string, createEventTypeVersion: CreateEventTypeVersion, options?: AxiosRequestConfig) {
        return EventTypeVersionsApiFp(this.configuration).createEventTypeVersionViaXRoad(memberId, roomId, eventType, createEventTypeVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an event type version for PubSub administrators
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} eventType The identifier of the event type
     * @param {number} version The version of the event type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypeVersionsApi
     */
    public deleteEventTypeVersionAsAdministrator(memberId: string, roomId: string, eventType: string, version: number, options?: AxiosRequestConfig) {
        return EventTypeVersionsApiFp(this.configuration).deleteEventTypeVersionAsAdministrator(memberId, roomId, eventType, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an event type version for PubSub managers
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} eventType The identifier of the event type
     * @param {number} version The version of the event type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypeVersionsApi
     */
    public deleteEventTypeVersionAsManager(roomId: string, eventType: string, version: number, options?: AxiosRequestConfig) {
        return EventTypeVersionsApiFp(this.configuration).deleteEventTypeVersionAsManager(roomId, eventType, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an event type version for PubSub managers accessing via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} eventType The identifier of the event type
     * @param {number} version The version of the event type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypeVersionsApi
     */
    public deleteEventTypeVersionViaXRoad(memberId: string, roomId: string, eventType: string, version: number, options?: AxiosRequestConfig) {
        return EventTypeVersionsApiFp(this.configuration).deleteEventTypeVersionViaXRoad(memberId, roomId, eventType, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all versions for an event type for PubSub administrators
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} eventType The identifier of the event type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypeVersionsApi
     */
    public getEventTypeVersionsAsAdministrator(memberId: string, roomId: string, eventType: string, options?: AxiosRequestConfig) {
        return EventTypeVersionsApiFp(this.configuration).getEventTypeVersionsAsAdministrator(memberId, roomId, eventType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all versions for an event type for PubSub managers
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} eventType The identifier of the event type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypeVersionsApi
     */
    public getEventTypeVersionsAsManager(roomId: string, eventType: string, options?: AxiosRequestConfig) {
        return EventTypeVersionsApiFp(this.configuration).getEventTypeVersionsAsManager(roomId, eventType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all versions for an event type for PubSub managers accessing via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} eventType The identifier of the event type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypeVersionsApi
     */
    public getEventTypeVersionsViaXRoad(memberId: string, roomId: string, eventType: string, options?: AxiosRequestConfig) {
        return EventTypeVersionsApiFp(this.configuration).getEventTypeVersionsViaXRoad(memberId, roomId, eventType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates versions for an event type for PubSub administrators
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} eventType The identifier of the event type
     * @param {UpdateEventTypeVersion} updateEventTypeVersion 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypeVersionsApi
     */
    public updateEventTypeVersionAsAdministrator(memberId: string, roomId: string, eventType: string, updateEventTypeVersion: UpdateEventTypeVersion, options?: AxiosRequestConfig) {
        return EventTypeVersionsApiFp(this.configuration).updateEventTypeVersionAsAdministrator(memberId, roomId, eventType, updateEventTypeVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates versions for an event type for PubSub managers
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} eventType The identifier of the event type
     * @param {UpdateEventTypeVersion} updateEventTypeVersion 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypeVersionsApi
     */
    public updateEventTypeVersionAsManager(roomId: string, eventType: string, updateEventTypeVersion: UpdateEventTypeVersion, options?: AxiosRequestConfig) {
        return EventTypeVersionsApiFp(this.configuration).updateEventTypeVersionAsManager(roomId, eventType, updateEventTypeVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates versions for an event type for PubSub managers accessing via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} eventType The identifier of the event type
     * @param {UpdateEventTypeVersion} updateEventTypeVersion 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypeVersionsApi
     */
    public updateEventTypeVersionViaXRoad(memberId: string, roomId: string, eventType: string, updateEventTypeVersion: UpdateEventTypeVersion, options?: AxiosRequestConfig) {
        return EventTypeVersionsApiFp(this.configuration).updateEventTypeVersionViaXRoad(memberId, roomId, eventType, updateEventTypeVersion, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventTypesApi - axios parameter creator
 * @export
 */
export const EventTypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates an event type in a message room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreateEventType} createEventType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventTypeAsAdministrator: async (memberId: string, roomId: string, createEventType: CreateEventType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('createEventTypeAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('createEventTypeAsAdministrator', 'roomId', roomId)
            // verify required parameter 'createEventType' is not null or undefined
            assertParamExists('createEventTypeAsAdministrator', 'createEventType', createEventType)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}/event-types`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an event type in a message room for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreateEventType} createEventType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventTypeAsManager: async (roomId: string, createEventType: CreateEventType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('createEventTypeAsManager', 'roomId', roomId)
            // verify required parameter 'createEventType' is not null or undefined
            assertParamExists('createEventTypeAsManager', 'createEventType', createEventType)
            const localVarPath = `/api/rooms/{roomId}/event-types`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an event type in a message room for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreateEventType} createEventType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventTypeViaXRoadNetwork: async (memberId: string, roomId: string, createEventType: CreateEventType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('createEventTypeViaXRoadNetwork', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('createEventTypeViaXRoadNetwork', 'roomId', roomId)
            // verify required parameter 'createEventType' is not null or undefined
            assertParamExists('createEventTypeViaXRoadNetwork', 'createEventType', createEventType)
            const localVarPath = `/rooms/{memberId}/{roomId}/event-types`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEventType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an event type in a message room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventTypeAsAdministrator: async (memberId: string, roomId: string, eventType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('deleteEventTypeAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('deleteEventTypeAsAdministrator', 'roomId', roomId)
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('deleteEventTypeAsAdministrator', 'eventType', eventType)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}/event-types/{eventType}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an event type in a message room for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventTypeAsManager: async (roomId: string, eventType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('deleteEventTypeAsManager', 'roomId', roomId)
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('deleteEventTypeAsManager', 'eventType', eventType)
            const localVarPath = `/api/rooms/{roomId}/event-types/{eventType}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an event type in a message room for PubSub manages accessing via XRoad
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventTypeViaXRoad: async (memberId: string, roomId: string, eventType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('deleteEventTypeViaXRoad', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('deleteEventTypeViaXRoad', 'roomId', roomId)
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('deleteEventTypeViaXRoad', 'eventType', eventType)
            const localVarPath = `/rooms/{memberId}/{roomId}/event-types/{eventType}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"eventType"}}`, encodeURIComponent(String(eventType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export all event type identifiers in a message room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportEventTypeIdentifiersAsAdministrator: async (memberId: string, roomId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('exportEventTypeIdentifiersAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('exportEventTypeIdentifiersAsAdministrator', 'roomId', roomId)
            const localVarPath = `/api/admin/export/rooms/{memberId}/{roomId}/event-types`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export all event type identifiers in a message room for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportEventTypeIdentifiersAsManager: async (roomId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('exportEventTypeIdentifiersAsManager', 'roomId', roomId)
            const localVarPath = `/api/export/rooms/{roomId}/event-types`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get event types available in a message room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTypesAsAdministrator: async (memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('getEventTypesAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getEventTypesAsAdministrator', 'roomId', roomId)
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('getEventTypesAsAdministrator', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}/event-types`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get event types available in a message room for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTypesAsManager: async (roomId: string, pagingSortingParameters: PagingSortingParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getEventTypesAsManager', 'roomId', roomId)
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('getEventTypesAsManager', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/api/rooms/{roomId}/event-types`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get event types available in a message room for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTypesViaXRoadNetwork: async (memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('getEventTypesViaXRoadNetwork', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getEventTypesViaXRoadNetwork', 'roomId', roomId)
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('getEventTypesViaXRoadNetwork', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/rooms/{memberId}/{roomId}/event-types`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventTypesApi - functional programming interface
 * @export
 */
export const EventTypesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventTypesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates an event type in a message room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreateEventType} createEventType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventTypeAsAdministrator(memberId: string, roomId: string, createEventType: CreateEventType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventTypeAsAdministrator(memberId, roomId, createEventType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates an event type in a message room for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreateEventType} createEventType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventTypeAsManager(roomId: string, createEventType: CreateEventType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventTypeAsManager(roomId, createEventType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates an event type in a message room for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreateEventType} createEventType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEventTypeViaXRoadNetwork(memberId: string, roomId: string, createEventType: CreateEventType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEventTypeViaXRoadNetwork(memberId, roomId, createEventType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes an event type in a message room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventTypeAsAdministrator(memberId: string, roomId: string, eventType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventTypeAsAdministrator(memberId, roomId, eventType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes an event type in a message room for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventTypeAsManager(roomId: string, eventType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventTypeAsManager(roomId, eventType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes an event type in a message room for PubSub manages accessing via XRoad
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEventTypeViaXRoad(memberId: string, roomId: string, eventType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEventTypeViaXRoad(memberId, roomId, eventType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Export all event type identifiers in a message room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportEventTypeIdentifiersAsAdministrator(memberId: string, roomId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportEventTypeIdentifiersAsAdministrator(memberId, roomId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Export all event type identifiers in a message room for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportEventTypeIdentifiersAsManager(roomId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportEventTypeIdentifiersAsManager(roomId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get event types available in a message room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventTypesAsAdministrator(memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedEventTypeViewsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventTypesAsAdministrator(memberId, roomId, pagingSortingParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get event types available in a message room for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventTypesAsManager(roomId: string, pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedEventTypeViewsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventTypesAsManager(roomId, pagingSortingParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get event types available in a message room for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEventTypesViaXRoadNetwork(memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedEventTypeViewsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEventTypesViaXRoadNetwork(memberId, roomId, pagingSortingParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventTypesApi - factory interface
 * @export
 */
export const EventTypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventTypesApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates an event type in a message room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreateEventType} createEventType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventTypeAsAdministrator(memberId: string, roomId: string, createEventType: CreateEventType, options?: any): AxiosPromise<void> {
            return localVarFp.createEventTypeAsAdministrator(memberId, roomId, createEventType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an event type in a message room for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreateEventType} createEventType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventTypeAsManager(roomId: string, createEventType: CreateEventType, options?: any): AxiosPromise<void> {
            return localVarFp.createEventTypeAsManager(roomId, createEventType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an event type in a message room for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreateEventType} createEventType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventTypeViaXRoadNetwork(memberId: string, roomId: string, createEventType: CreateEventType, options?: any): AxiosPromise<void> {
            return localVarFp.createEventTypeViaXRoadNetwork(memberId, roomId, createEventType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an event type in a message room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventTypeAsAdministrator(memberId: string, roomId: string, eventType: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEventTypeAsAdministrator(memberId, roomId, eventType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an event type in a message room for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventTypeAsManager(roomId: string, eventType: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEventTypeAsManager(roomId, eventType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an event type in a message room for PubSub manages accessing via XRoad
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} eventType The identifier of the event type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEventTypeViaXRoad(memberId: string, roomId: string, eventType: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEventTypeViaXRoad(memberId, roomId, eventType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export all event type identifiers in a message room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportEventTypeIdentifiersAsAdministrator(memberId: string, roomId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.exportEventTypeIdentifiersAsAdministrator(memberId, roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export all event type identifiers in a message room for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportEventTypeIdentifiersAsManager(roomId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.exportEventTypeIdentifiersAsManager(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get event types available in a message room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTypesAsAdministrator(memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, options?: any): AxiosPromise<PagedEventTypeViewsResponse> {
            return localVarFp.getEventTypesAsAdministrator(memberId, roomId, pagingSortingParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get event types available in a message room for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTypesAsManager(roomId: string, pagingSortingParameters: PagingSortingParameters, options?: any): AxiosPromise<PagedEventTypeViewsResponse> {
            return localVarFp.getEventTypesAsManager(roomId, pagingSortingParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get event types available in a message room for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventTypesViaXRoadNetwork(memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, options?: any): AxiosPromise<PagedEventTypeViewsResponse> {
            return localVarFp.getEventTypesViaXRoadNetwork(memberId, roomId, pagingSortingParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventTypesApi - object-oriented interface
 * @export
 * @class EventTypesApi
 * @extends {BaseAPI}
 */
export class EventTypesApi extends BaseAPI {
    /**
     * 
     * @summary Creates an event type in a message room for PubSub administrators
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {CreateEventType} createEventType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypesApi
     */
    public createEventTypeAsAdministrator(memberId: string, roomId: string, createEventType: CreateEventType, options?: AxiosRequestConfig) {
        return EventTypesApiFp(this.configuration).createEventTypeAsAdministrator(memberId, roomId, createEventType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an event type in a message room for PubSub managers
     * @param {string} roomId Identifier of an existing active message room
     * @param {CreateEventType} createEventType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypesApi
     */
    public createEventTypeAsManager(roomId: string, createEventType: CreateEventType, options?: AxiosRequestConfig) {
        return EventTypesApiFp(this.configuration).createEventTypeAsManager(roomId, createEventType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an event type in a message room for PubSub managers accessing via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {CreateEventType} createEventType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypesApi
     */
    public createEventTypeViaXRoadNetwork(memberId: string, roomId: string, createEventType: CreateEventType, options?: AxiosRequestConfig) {
        return EventTypesApiFp(this.configuration).createEventTypeViaXRoadNetwork(memberId, roomId, createEventType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an event type in a message room for PubSub administrators
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} eventType The identifier of the event type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypesApi
     */
    public deleteEventTypeAsAdministrator(memberId: string, roomId: string, eventType: string, options?: AxiosRequestConfig) {
        return EventTypesApiFp(this.configuration).deleteEventTypeAsAdministrator(memberId, roomId, eventType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an event type in a message room for PubSub managers
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} eventType The identifier of the event type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypesApi
     */
    public deleteEventTypeAsManager(roomId: string, eventType: string, options?: AxiosRequestConfig) {
        return EventTypesApiFp(this.configuration).deleteEventTypeAsManager(roomId, eventType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an event type in a message room for PubSub manages accessing via XRoad
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} eventType The identifier of the event type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypesApi
     */
    public deleteEventTypeViaXRoad(memberId: string, roomId: string, eventType: string, options?: AxiosRequestConfig) {
        return EventTypesApiFp(this.configuration).deleteEventTypeViaXRoad(memberId, roomId, eventType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export all event type identifiers in a message room for PubSub administrators
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypesApi
     */
    public exportEventTypeIdentifiersAsAdministrator(memberId: string, roomId: string, options?: AxiosRequestConfig) {
        return EventTypesApiFp(this.configuration).exportEventTypeIdentifiersAsAdministrator(memberId, roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export all event type identifiers in a message room for PubSub managers
     * @param {string} roomId Identifier of an existing active message room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypesApi
     */
    public exportEventTypeIdentifiersAsManager(roomId: string, options?: AxiosRequestConfig) {
        return EventTypesApiFp(this.configuration).exportEventTypeIdentifiersAsManager(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get event types available in a message room for PubSub administrators
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypesApi
     */
    public getEventTypesAsAdministrator(memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig) {
        return EventTypesApiFp(this.configuration).getEventTypesAsAdministrator(memberId, roomId, pagingSortingParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get event types available in a message room for PubSub managers
     * @param {string} roomId Identifier of an existing active message room
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypesApi
     */
    public getEventTypesAsManager(roomId: string, pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig) {
        return EventTypesApiFp(this.configuration).getEventTypesAsManager(roomId, pagingSortingParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get event types available in a message room for PubSub managers accessing via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventTypesApi
     */
    public getEventTypesViaXRoadNetwork(memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig) {
        return EventTypesApiFp(this.configuration).getEventTypesViaXRoadNetwork(memberId, roomId, pagingSortingParameters, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ManagersApi - axios parameter creator
 * @export
 */
export const ManagersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a manager
         * @param {CreateManagerRequest} createManagerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManager: async (createManagerRequest: CreateManagerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createManagerRequest' is not null or undefined
            assertParamExists('createManager', 'createManagerRequest', createManagerRequest)
            const localVarPath = `/api/admin/managers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createManagerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves all managers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAllManagers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/export/managers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves page of managers
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveManagers: async (pagingSortingParameters: PagingSortingParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('retrieveManagers', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/api/admin/managers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Terminates a manager
         * @param {string} managerId The manager id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateManager: async (managerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'managerId' is not null or undefined
            assertParamExists('terminateManager', 'managerId', managerId)
            const localVarPath = `/api/admin/managers/{managerId}`
                .replace(`{${"managerId"}}`, encodeURIComponent(String(managerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManagersApi - functional programming interface
 * @export
 */
export const ManagersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManagersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a manager
         * @param {CreateManagerRequest} createManagerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createManager(createManagerRequest: CreateManagerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManagerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createManager(createManagerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves all managers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAllManagers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ManagerResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAllManagers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves page of managers
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveManagers(pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedManagersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveManagers(pagingSortingParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Terminates a manager
         * @param {string} managerId The manager id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateManager(managerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateManager(managerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManagersApi - factory interface
 * @export
 */
export const ManagersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManagersApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a manager
         * @param {CreateManagerRequest} createManagerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManager(createManagerRequest: CreateManagerRequest, options?: any): AxiosPromise<ManagerResponse> {
            return localVarFp.createManager(createManagerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves all managers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAllManagers(options?: any): AxiosPromise<Array<ManagerResponse>> {
            return localVarFp.retrieveAllManagers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves page of managers
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveManagers(pagingSortingParameters: PagingSortingParameters, options?: any): AxiosPromise<PagedManagersResponse> {
            return localVarFp.retrieveManagers(pagingSortingParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Terminates a manager
         * @param {string} managerId The manager id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateManager(managerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.terminateManager(managerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManagersApi - object-oriented interface
 * @export
 * @class ManagersApi
 * @extends {BaseAPI}
 */
export class ManagersApi extends BaseAPI {
    /**
     * 
     * @summary Creates a manager
     * @param {CreateManagerRequest} createManagerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagersApi
     */
    public createManager(createManagerRequest: CreateManagerRequest, options?: AxiosRequestConfig) {
        return ManagersApiFp(this.configuration).createManager(createManagerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves all managers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagersApi
     */
    public retrieveAllManagers(options?: AxiosRequestConfig) {
        return ManagersApiFp(this.configuration).retrieveAllManagers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves page of managers
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagersApi
     */
    public retrieveManagers(pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig) {
        return ManagersApiFp(this.configuration).retrieveManagers(pagingSortingParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Terminates a manager
     * @param {string} managerId The manager id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagersApi
     */
    public terminateManager(managerId: string, options?: AxiosRequestConfig) {
        return ManagersApiFp(this.configuration).terminateManager(managerId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MembersApi - axios parameter creator
 * @export
 */
export const MembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieves members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportMembers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin/export/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportMembers1: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/export/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves page of members
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMembersPage: async (pagingSortingParameters: PagingSortingParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('retrieveMembersPage', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/api/admin/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves page of members
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMembersPage1: async (pagingSortingParameters: PagingSortingParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('retrieveMembersPage1', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/api/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MembersApi - functional programming interface
 * @export
 */
export const MembersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MembersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieves members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportMembers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemberData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportMembers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportMembers1(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemberData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportMembers1(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves page of members
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveMembersPage(pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MembersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveMembersPage(pagingSortingParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves page of members
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveMembersPage1(pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MembersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveMembersPage1(pagingSortingParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MembersApi - factory interface
 * @export
 */
export const MembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MembersApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieves members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportMembers(options?: any): AxiosPromise<Array<MemberData>> {
            return localVarFp.exportMembers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportMembers1(options?: any): AxiosPromise<Array<MemberData>> {
            return localVarFp.exportMembers1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves page of members
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMembersPage(pagingSortingParameters: PagingSortingParameters, options?: any): AxiosPromise<MembersResponse> {
            return localVarFp.retrieveMembersPage(pagingSortingParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves page of members
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMembersPage1(pagingSortingParameters: PagingSortingParameters, options?: any): AxiosPromise<MembersResponse> {
            return localVarFp.retrieveMembersPage1(pagingSortingParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MembersApi - object-oriented interface
 * @export
 * @class MembersApi
 * @extends {BaseAPI}
 */
export class MembersApi extends BaseAPI {
    /**
     * 
     * @summary Retrieves members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public exportMembers(options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).exportMembers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public exportMembers1(options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).exportMembers1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves page of members
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public retrieveMembersPage(pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).retrieveMembersPage(pagingSortingParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves page of members
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MembersApi
     */
    public retrieveMembersPage1(pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig) {
        return MembersApiFp(this.configuration).retrieveMembersPage1(pagingSortingParameters, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PublishersApi - axios parameter creator
 * @export
 */
export const PublishersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a publisher in a message room for a PubSub administrator
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreatePublisherRequest} createPublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublisherAsAdministrator: async (memberId: string, roomId: string, createPublisherRequest: CreatePublisherRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('createPublisherAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('createPublisherAsAdministrator', 'roomId', roomId)
            // verify required parameter 'createPublisherRequest' is not null or undefined
            assertParamExists('createPublisherAsAdministrator', 'createPublisherRequest', createPublisherRequest)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}/publishers`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPublisherRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a publisher in a message room for a PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreatePublisherRequest} createPublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublisherAsManager: async (roomId: string, createPublisherRequest: CreatePublisherRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('createPublisherAsManager', 'roomId', roomId)
            // verify required parameter 'createPublisherRequest' is not null or undefined
            assertParamExists('createPublisherAsManager', 'createPublisherRequest', createPublisherRequest)
            const localVarPath = `/api/rooms/{roomId}/publishers`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPublisherRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a publisher in a message room for a PubSub member accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreatePublisherRequest} createPublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublisherViaXRoad: async (memberId: string, roomId: string, createPublisherRequest: CreatePublisherRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('createPublisherViaXRoad', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('createPublisherViaXRoad', 'roomId', roomId)
            // verify required parameter 'createPublisherRequest' is not null or undefined
            assertParamExists('createPublisherViaXRoad', 'createPublisherRequest', createPublisherRequest)
            const localVarPath = `/rooms/{memberId}/{roomId}/publishers`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPublisherRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all publishers in a message room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishersAsAdministrator: async (memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('getPublishersAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getPublishersAsAdministrator', 'roomId', roomId)
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('getPublishersAsAdministrator', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}/publishers`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all publishers in a message room for PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishersAsManager: async (roomId: string, pagingSortingParameters: PagingSortingParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getPublishersAsManager', 'roomId', roomId)
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('getPublishersAsManager', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/api/rooms/{roomId}/publishers`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all publishers in a message room for PubSub members accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishersViaXroad: async (memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('getPublishersViaXroad', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getPublishersViaXroad', 'roomId', roomId)
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('getPublishersViaXroad', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/rooms/{memberId}/{roomId}/publishers`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Terminate a publisher in a message room for a PubSub administrator
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} publisherId The publisher UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminatePublisherAsAdministrator: async (memberId: string, roomId: string, publisherId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('terminatePublisherAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('terminatePublisherAsAdministrator', 'roomId', roomId)
            // verify required parameter 'publisherId' is not null or undefined
            assertParamExists('terminatePublisherAsAdministrator', 'publisherId', publisherId)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}/publishers/{publisherId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"publisherId"}}`, encodeURIComponent(String(publisherId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Terminate a publisher in a message room for a PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} publisherId The publisher UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminatePublisherAsManager: async (roomId: string, publisherId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('terminatePublisherAsManager', 'roomId', roomId)
            // verify required parameter 'publisherId' is not null or undefined
            assertParamExists('terminatePublisherAsManager', 'publisherId', publisherId)
            const localVarPath = `/api/rooms/{roomId}/publishers/{publisherId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"publisherId"}}`, encodeURIComponent(String(publisherId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Terminate a publisher in a message room for a PubSub member accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} publisherId The publisher UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminatePublisherViaXRoad: async (memberId: string, roomId: string, publisherId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('terminatePublisherViaXRoad', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('terminatePublisherViaXRoad', 'roomId', roomId)
            // verify required parameter 'publisherId' is not null or undefined
            assertParamExists('terminatePublisherViaXRoad', 'publisherId', publisherId)
            const localVarPath = `/rooms/{memberId}/{roomId}/publishers/{publisherId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"publisherId"}}`, encodeURIComponent(String(publisherId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update publisher\'s constraints in a message room for a PubSub administrator
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} publisherId The publisher UUID
         * @param {UpdatePublisherRequest} updatePublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublisherAsAdministrator: async (memberId: string, roomId: string, publisherId: string, updatePublisherRequest: UpdatePublisherRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('updatePublisherAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('updatePublisherAsAdministrator', 'roomId', roomId)
            // verify required parameter 'publisherId' is not null or undefined
            assertParamExists('updatePublisherAsAdministrator', 'publisherId', publisherId)
            // verify required parameter 'updatePublisherRequest' is not null or undefined
            assertParamExists('updatePublisherAsAdministrator', 'updatePublisherRequest', updatePublisherRequest)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}/publishers/{publisherId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"publisherId"}}`, encodeURIComponent(String(publisherId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePublisherRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update publisher\'s constraints in a message room for a PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} publisherId The publisher UUID
         * @param {UpdatePublisherRequest} updatePublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublisherAsManager: async (roomId: string, publisherId: string, updatePublisherRequest: UpdatePublisherRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('updatePublisherAsManager', 'roomId', roomId)
            // verify required parameter 'publisherId' is not null or undefined
            assertParamExists('updatePublisherAsManager', 'publisherId', publisherId)
            // verify required parameter 'updatePublisherRequest' is not null or undefined
            assertParamExists('updatePublisherAsManager', 'updatePublisherRequest', updatePublisherRequest)
            const localVarPath = `/api/rooms/{roomId}/publishers/{publisherId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"publisherId"}}`, encodeURIComponent(String(publisherId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePublisherRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update publisher\'s constraints in a message room for a PubSub member accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} publisherId The publisher UUID
         * @param {UpdatePublisherRequest} updatePublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublisherViaXRoad: async (memberId: string, roomId: string, publisherId: string, updatePublisherRequest: UpdatePublisherRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('updatePublisherViaXRoad', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('updatePublisherViaXRoad', 'roomId', roomId)
            // verify required parameter 'publisherId' is not null or undefined
            assertParamExists('updatePublisherViaXRoad', 'publisherId', publisherId)
            // verify required parameter 'updatePublisherRequest' is not null or undefined
            assertParamExists('updatePublisherViaXRoad', 'updatePublisherRequest', updatePublisherRequest)
            const localVarPath = `/rooms/{memberId}/{roomId}/publishers/{publisherId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"publisherId"}}`, encodeURIComponent(String(publisherId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePublisherRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublishersApi - functional programming interface
 * @export
 */
export const PublishersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublishersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a publisher in a message room for a PubSub administrator
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreatePublisherRequest} createPublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublisherAsAdministrator(memberId: string, roomId: string, createPublisherRequest: CreatePublisherRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePublisherResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublisherAsAdministrator(memberId, roomId, createPublisherRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a publisher in a message room for a PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreatePublisherRequest} createPublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublisherAsManager(roomId: string, createPublisherRequest: CreatePublisherRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePublisherResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublisherAsManager(roomId, createPublisherRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a publisher in a message room for a PubSub member accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreatePublisherRequest} createPublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublisherViaXRoad(memberId: string, roomId: string, createPublisherRequest: CreatePublisherRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePublisherResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublisherViaXRoad(memberId, roomId, createPublisherRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists all publishers in a message room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublishersAsAdministrator(memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPublishersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishersAsAdministrator(memberId, roomId, pagingSortingParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists all publishers in a message room for PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublishersAsManager(roomId: string, pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPublishersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishersAsManager(roomId, pagingSortingParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Lists all publishers in a message room for PubSub members accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublishersViaXroad(memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPublishersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishersViaXroad(memberId, roomId, pagingSortingParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Terminate a publisher in a message room for a PubSub administrator
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} publisherId The publisher UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminatePublisherAsAdministrator(memberId: string, roomId: string, publisherId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminatePublisherAsAdministrator(memberId, roomId, publisherId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Terminate a publisher in a message room for a PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} publisherId The publisher UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminatePublisherAsManager(roomId: string, publisherId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminatePublisherAsManager(roomId, publisherId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Terminate a publisher in a message room for a PubSub member accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} publisherId The publisher UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminatePublisherViaXRoad(memberId: string, roomId: string, publisherId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminatePublisherViaXRoad(memberId, roomId, publisherId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update publisher\'s constraints in a message room for a PubSub administrator
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} publisherId The publisher UUID
         * @param {UpdatePublisherRequest} updatePublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublisherAsAdministrator(memberId: string, roomId: string, publisherId: string, updatePublisherRequest: UpdatePublisherRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublisherAsAdministrator(memberId, roomId, publisherId, updatePublisherRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update publisher\'s constraints in a message room for a PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} publisherId The publisher UUID
         * @param {UpdatePublisherRequest} updatePublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublisherAsManager(roomId: string, publisherId: string, updatePublisherRequest: UpdatePublisherRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublisherAsManager(roomId, publisherId, updatePublisherRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update publisher\'s constraints in a message room for a PubSub member accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} publisherId The publisher UUID
         * @param {UpdatePublisherRequest} updatePublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublisherViaXRoad(memberId: string, roomId: string, publisherId: string, updatePublisherRequest: UpdatePublisherRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublisherViaXRoad(memberId, roomId, publisherId, updatePublisherRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublishersApi - factory interface
 * @export
 */
export const PublishersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublishersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a publisher in a message room for a PubSub administrator
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreatePublisherRequest} createPublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublisherAsAdministrator(memberId: string, roomId: string, createPublisherRequest: CreatePublisherRequest, options?: any): AxiosPromise<CreatePublisherResponse> {
            return localVarFp.createPublisherAsAdministrator(memberId, roomId, createPublisherRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a publisher in a message room for a PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreatePublisherRequest} createPublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublisherAsManager(roomId: string, createPublisherRequest: CreatePublisherRequest, options?: any): AxiosPromise<CreatePublisherResponse> {
            return localVarFp.createPublisherAsManager(roomId, createPublisherRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a publisher in a message room for a PubSub member accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreatePublisherRequest} createPublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublisherViaXRoad(memberId: string, roomId: string, createPublisherRequest: CreatePublisherRequest, options?: any): AxiosPromise<CreatePublisherResponse> {
            return localVarFp.createPublisherViaXRoad(memberId, roomId, createPublisherRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all publishers in a message room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishersAsAdministrator(memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, options?: any): AxiosPromise<PaginatedPublishersResponse> {
            return localVarFp.getPublishersAsAdministrator(memberId, roomId, pagingSortingParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all publishers in a message room for PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishersAsManager(roomId: string, pagingSortingParameters: PagingSortingParameters, options?: any): AxiosPromise<PaginatedPublishersResponse> {
            return localVarFp.getPublishersAsManager(roomId, pagingSortingParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all publishers in a message room for PubSub members accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishersViaXroad(memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, options?: any): AxiosPromise<PaginatedPublishersResponse> {
            return localVarFp.getPublishersViaXroad(memberId, roomId, pagingSortingParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Terminate a publisher in a message room for a PubSub administrator
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} publisherId The publisher UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminatePublisherAsAdministrator(memberId: string, roomId: string, publisherId: string, options?: any): AxiosPromise<void> {
            return localVarFp.terminatePublisherAsAdministrator(memberId, roomId, publisherId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Terminate a publisher in a message room for a PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} publisherId The publisher UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminatePublisherAsManager(roomId: string, publisherId: string, options?: any): AxiosPromise<void> {
            return localVarFp.terminatePublisherAsManager(roomId, publisherId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Terminate a publisher in a message room for a PubSub member accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} publisherId The publisher UUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminatePublisherViaXRoad(memberId: string, roomId: string, publisherId: string, options?: any): AxiosPromise<void> {
            return localVarFp.terminatePublisherViaXRoad(memberId, roomId, publisherId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update publisher\'s constraints in a message room for a PubSub administrator
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} publisherId The publisher UUID
         * @param {UpdatePublisherRequest} updatePublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublisherAsAdministrator(memberId: string, roomId: string, publisherId: string, updatePublisherRequest: UpdatePublisherRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updatePublisherAsAdministrator(memberId, roomId, publisherId, updatePublisherRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update publisher\'s constraints in a message room for a PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} publisherId The publisher UUID
         * @param {UpdatePublisherRequest} updatePublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublisherAsManager(roomId: string, publisherId: string, updatePublisherRequest: UpdatePublisherRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updatePublisherAsManager(roomId, publisherId, updatePublisherRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update publisher\'s constraints in a message room for a PubSub member accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} publisherId The publisher UUID
         * @param {UpdatePublisherRequest} updatePublisherRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublisherViaXRoad(memberId: string, roomId: string, publisherId: string, updatePublisherRequest: UpdatePublisherRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updatePublisherViaXRoad(memberId, roomId, publisherId, updatePublisherRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublishersApi - object-oriented interface
 * @export
 * @class PublishersApi
 * @extends {BaseAPI}
 */
export class PublishersApi extends BaseAPI {
    /**
     * 
     * @summary Create a publisher in a message room for a PubSub administrator
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {CreatePublisherRequest} createPublisherRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishersApi
     */
    public createPublisherAsAdministrator(memberId: string, roomId: string, createPublisherRequest: CreatePublisherRequest, options?: AxiosRequestConfig) {
        return PublishersApiFp(this.configuration).createPublisherAsAdministrator(memberId, roomId, createPublisherRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a publisher in a message room for a PubSub manager
     * @param {string} roomId Identifier of an existing active message room
     * @param {CreatePublisherRequest} createPublisherRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishersApi
     */
    public createPublisherAsManager(roomId: string, createPublisherRequest: CreatePublisherRequest, options?: AxiosRequestConfig) {
        return PublishersApiFp(this.configuration).createPublisherAsManager(roomId, createPublisherRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a publisher in a message room for a PubSub member accessing via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {CreatePublisherRequest} createPublisherRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishersApi
     */
    public createPublisherViaXRoad(memberId: string, roomId: string, createPublisherRequest: CreatePublisherRequest, options?: AxiosRequestConfig) {
        return PublishersApiFp(this.configuration).createPublisherViaXRoad(memberId, roomId, createPublisherRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all publishers in a message room for PubSub administrators
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishersApi
     */
    public getPublishersAsAdministrator(memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig) {
        return PublishersApiFp(this.configuration).getPublishersAsAdministrator(memberId, roomId, pagingSortingParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all publishers in a message room for PubSub manager
     * @param {string} roomId Identifier of an existing active message room
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishersApi
     */
    public getPublishersAsManager(roomId: string, pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig) {
        return PublishersApiFp(this.configuration).getPublishersAsManager(roomId, pagingSortingParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all publishers in a message room for PubSub members accessing via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishersApi
     */
    public getPublishersViaXroad(memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig) {
        return PublishersApiFp(this.configuration).getPublishersViaXroad(memberId, roomId, pagingSortingParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Terminate a publisher in a message room for a PubSub administrator
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} publisherId The publisher UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishersApi
     */
    public terminatePublisherAsAdministrator(memberId: string, roomId: string, publisherId: string, options?: AxiosRequestConfig) {
        return PublishersApiFp(this.configuration).terminatePublisherAsAdministrator(memberId, roomId, publisherId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Terminate a publisher in a message room for a PubSub manager
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} publisherId The publisher UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishersApi
     */
    public terminatePublisherAsManager(roomId: string, publisherId: string, options?: AxiosRequestConfig) {
        return PublishersApiFp(this.configuration).terminatePublisherAsManager(roomId, publisherId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Terminate a publisher in a message room for a PubSub member accessing via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} publisherId The publisher UUID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishersApi
     */
    public terminatePublisherViaXRoad(memberId: string, roomId: string, publisherId: string, options?: AxiosRequestConfig) {
        return PublishersApiFp(this.configuration).terminatePublisherViaXRoad(memberId, roomId, publisherId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update publisher\'s constraints in a message room for a PubSub administrator
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} publisherId The publisher UUID
     * @param {UpdatePublisherRequest} updatePublisherRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishersApi
     */
    public updatePublisherAsAdministrator(memberId: string, roomId: string, publisherId: string, updatePublisherRequest: UpdatePublisherRequest, options?: AxiosRequestConfig) {
        return PublishersApiFp(this.configuration).updatePublisherAsAdministrator(memberId, roomId, publisherId, updatePublisherRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update publisher\'s constraints in a message room for a PubSub manager
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} publisherId The publisher UUID
     * @param {UpdatePublisherRequest} updatePublisherRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishersApi
     */
    public updatePublisherAsManager(roomId: string, publisherId: string, updatePublisherRequest: UpdatePublisherRequest, options?: AxiosRequestConfig) {
        return PublishersApiFp(this.configuration).updatePublisherAsManager(roomId, publisherId, updatePublisherRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update publisher\'s constraints in a message room for a PubSub member accessing via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} publisherId The publisher UUID
     * @param {UpdatePublisherRequest} updatePublisherRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishersApi
     */
    public updatePublisherViaXRoad(memberId: string, roomId: string, publisherId: string, updatePublisherRequest: UpdatePublisherRequest, options?: AxiosRequestConfig) {
        return PublishersApiFp(this.configuration).updatePublisherViaXRoad(memberId, roomId, publisherId, updatePublisherRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoomsApi - axios parameter creator
 * @export
 */
export const RoomsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new room
         * @param {CreateRoomRequest} createRoomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoom: async (createRoomRequest: CreateRoomRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRoomRequest' is not null or undefined
            assertParamExists('createRoom', 'createRoomRequest', createRoomRequest)
            const localVarPath = `/api/admin/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoomRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get room full details for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomDetailsAsAdministrator: async (memberId: string, roomId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('getRoomDetailsAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getRoomDetailsAsAdministrator', 'roomId', roomId)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get room full details for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomDetailsAsManager: async (roomId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getRoomDetailsAsManager', 'roomId', roomId)
            const localVarPath = `/api/rooms/{roomId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get room full details for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomDetailsViaXRoad: async (memberId: string, roomId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('getRoomDetailsViaXRoad', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('getRoomDetailsViaXRoad', 'roomId', roomId)
            const localVarPath = `/rooms/{memberId}/{roomId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves all rooms (or rooms of a specific manager) for PubSub administrator
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [managerIdentifier] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoomsAsAdministrator: async (pagingSortingParameters: PagingSortingParameters, managerIdentifier?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('listRoomsAsAdministrator', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/api/admin/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (managerIdentifier !== undefined) {
                localVarQueryParameter['managerIdentifier'] = managerIdentifier;
            }

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves all rooms for PubSub managers
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoomsAsManager: async (pagingSortingParameters: PagingSortingParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('listRoomsAsManager', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/api/rooms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves all rooms for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoomsViaXRoad: async (memberId: string, pagingSortingParameters: PagingSortingParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('listRoomsViaXRoad', 'memberId', memberId)
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('listRoomsViaXRoad', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/rooms/{memberId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify an existing room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {ModifyRoomRequest} modifyRoomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyRoomAsAdministrator: async (memberId: string, roomId: string, modifyRoomRequest: ModifyRoomRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('modifyRoomAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('modifyRoomAsAdministrator', 'roomId', roomId)
            // verify required parameter 'modifyRoomRequest' is not null or undefined
            assertParamExists('modifyRoomAsAdministrator', 'modifyRoomRequest', modifyRoomRequest)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyRoomRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify an existing room for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {ModifyRoomRequest} modifyRoomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyRoomAsManager: async (roomId: string, modifyRoomRequest: ModifyRoomRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('modifyRoomAsManager', 'roomId', roomId)
            // verify required parameter 'modifyRoomRequest' is not null or undefined
            assertParamExists('modifyRoomAsManager', 'modifyRoomRequest', modifyRoomRequest)
            const localVarPath = `/api/rooms/{roomId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyRoomRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify an existing room for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {ModifyRoomRequest} modifyRoomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyRoomViaXRoad: async (memberId: string, roomId: string, modifyRoomRequest: ModifyRoomRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('modifyRoomViaXRoad', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('modifyRoomViaXRoad', 'roomId', roomId)
            // verify required parameter 'modifyRoomRequest' is not null or undefined
            assertParamExists('modifyRoomViaXRoad', 'modifyRoomRequest', modifyRoomRequest)
            const localVarPath = `/rooms/{memberId}/{roomId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modifyRoomRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Terminates an existing active room for PubSub administrators
         * @param {string} memberId 
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateRoomAsAdministrator: async (memberId: string, roomId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('terminateRoomAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('terminateRoomAsAdministrator', 'roomId', roomId)
            const localVarPath = `/api/admin/rooms/admin/{memberId}/{roomId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Terminates an existing active room for PubSub managers
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateRoomAsManager: async (roomId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('terminateRoomAsManager', 'roomId', roomId)
            const localVarPath = `/api/rooms/{roomId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Terminates an existing active room for PubSub managers accessing via XRoad network
         * @param {string} memberId 
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateRoomViaXRoad: async (memberId: string, roomId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('terminateRoomViaXRoad', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('terminateRoomViaXRoad', 'roomId', roomId)
            const localVarPath = `/rooms/{memberId}/{roomId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomsApi - functional programming interface
 * @export
 */
export const RoomsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new room
         * @param {CreateRoomRequest} createRoomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoom(createRoomRequest: CreateRoomRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateRoomResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoom(createRoomRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get room full details for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomDetailsAsAdministrator(memberId: string, roomId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomFullResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomDetailsAsAdministrator(memberId, roomId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get room full details for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomDetailsAsManager(roomId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomFullResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomDetailsAsManager(roomId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get room full details for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomDetailsViaXRoad(memberId: string, roomId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomFullResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomDetailsViaXRoad(memberId, roomId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves all rooms (or rooms of a specific manager) for PubSub administrator
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [managerIdentifier] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoomsAsAdministrator(pagingSortingParameters: PagingSortingParameters, managerIdentifier?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRoomsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoomsAsAdministrator(pagingSortingParameters, managerIdentifier, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves all rooms for PubSub managers
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoomsAsManager(pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRoomsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoomsAsManager(pagingSortingParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieves all rooms for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoomsViaXRoad(memberId: string, pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRoomsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoomsViaXRoad(memberId, pagingSortingParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify an existing room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {ModifyRoomRequest} modifyRoomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyRoomAsAdministrator(memberId: string, roomId: string, modifyRoomRequest: ModifyRoomRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDetailedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyRoomAsAdministrator(memberId, roomId, modifyRoomRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify an existing room for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {ModifyRoomRequest} modifyRoomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyRoomAsManager(roomId: string, modifyRoomRequest: ModifyRoomRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDetailedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyRoomAsManager(roomId, modifyRoomRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify an existing room for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {ModifyRoomRequest} modifyRoomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyRoomViaXRoad(memberId: string, roomId: string, modifyRoomRequest: ModifyRoomRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDetailedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyRoomViaXRoad(memberId, roomId, modifyRoomRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Terminates an existing active room for PubSub administrators
         * @param {string} memberId 
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateRoomAsAdministrator(memberId: string, roomId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateRoomAsAdministrator(memberId, roomId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Terminates an existing active room for PubSub managers
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateRoomAsManager(roomId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateRoomAsManager(roomId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Terminates an existing active room for PubSub managers accessing via XRoad network
         * @param {string} memberId 
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateRoomViaXRoad(memberId: string, roomId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateRoomViaXRoad(memberId, roomId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RoomsApi - factory interface
 * @export
 */
export const RoomsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new room
         * @param {CreateRoomRequest} createRoomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoom(createRoomRequest: CreateRoomRequest, options?: any): AxiosPromise<CreateRoomResponse> {
            return localVarFp.createRoom(createRoomRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get room full details for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomDetailsAsAdministrator(memberId: string, roomId: string, options?: any): AxiosPromise<RoomFullResponse> {
            return localVarFp.getRoomDetailsAsAdministrator(memberId, roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get room full details for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomDetailsAsManager(roomId: string, options?: any): AxiosPromise<RoomFullResponse> {
            return localVarFp.getRoomDetailsAsManager(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get room full details for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomDetailsViaXRoad(memberId: string, roomId: string, options?: any): AxiosPromise<RoomFullResponse> {
            return localVarFp.getRoomDetailsViaXRoad(memberId, roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves all rooms (or rooms of a specific manager) for PubSub administrator
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [managerIdentifier] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoomsAsAdministrator(pagingSortingParameters: PagingSortingParameters, managerIdentifier?: string, options?: any): AxiosPromise<PaginatedRoomsResponse> {
            return localVarFp.listRoomsAsAdministrator(pagingSortingParameters, managerIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves all rooms for PubSub managers
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoomsAsManager(pagingSortingParameters: PagingSortingParameters, options?: any): AxiosPromise<PaginatedRoomsResponse> {
            return localVarFp.listRoomsAsManager(pagingSortingParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves all rooms for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoomsViaXRoad(memberId: string, pagingSortingParameters: PagingSortingParameters, options?: any): AxiosPromise<PaginatedRoomsResponse> {
            return localVarFp.listRoomsViaXRoad(memberId, pagingSortingParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify an existing room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {ModifyRoomRequest} modifyRoomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyRoomAsAdministrator(memberId: string, roomId: string, modifyRoomRequest: ModifyRoomRequest, options?: any): AxiosPromise<RoomDetailedResponse> {
            return localVarFp.modifyRoomAsAdministrator(memberId, roomId, modifyRoomRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify an existing room for PubSub managers
         * @param {string} roomId Identifier of an existing active message room
         * @param {ModifyRoomRequest} modifyRoomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyRoomAsManager(roomId: string, modifyRoomRequest: ModifyRoomRequest, options?: any): AxiosPromise<RoomDetailedResponse> {
            return localVarFp.modifyRoomAsManager(roomId, modifyRoomRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify an existing room for PubSub managers accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {ModifyRoomRequest} modifyRoomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyRoomViaXRoad(memberId: string, roomId: string, modifyRoomRequest: ModifyRoomRequest, options?: any): AxiosPromise<RoomDetailedResponse> {
            return localVarFp.modifyRoomViaXRoad(memberId, roomId, modifyRoomRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Terminates an existing active room for PubSub administrators
         * @param {string} memberId 
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateRoomAsAdministrator(memberId: string, roomId: string, options?: any): AxiosPromise<void> {
            return localVarFp.terminateRoomAsAdministrator(memberId, roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Terminates an existing active room for PubSub managers
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateRoomAsManager(roomId: string, options?: any): AxiosPromise<void> {
            return localVarFp.terminateRoomAsManager(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Terminates an existing active room for PubSub managers accessing via XRoad network
         * @param {string} memberId 
         * @param {string} roomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateRoomViaXRoad(memberId: string, roomId: string, options?: any): AxiosPromise<void> {
            return localVarFp.terminateRoomViaXRoad(memberId, roomId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomsApi - object-oriented interface
 * @export
 * @class RoomsApi
 * @extends {BaseAPI}
 */
export class RoomsApi extends BaseAPI {
    /**
     * 
     * @summary Create a new room
     * @param {CreateRoomRequest} createRoomRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public createRoom(createRoomRequest: CreateRoomRequest, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).createRoom(createRoomRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get room full details for PubSub administrators
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getRoomDetailsAsAdministrator(memberId: string, roomId: string, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getRoomDetailsAsAdministrator(memberId, roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get room full details for PubSub managers
     * @param {string} roomId Identifier of an existing active message room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getRoomDetailsAsManager(roomId: string, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getRoomDetailsAsManager(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get room full details for PubSub managers accessing via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public getRoomDetailsViaXRoad(memberId: string, roomId: string, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).getRoomDetailsViaXRoad(memberId, roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves all rooms (or rooms of a specific manager) for PubSub administrator
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {string} [managerIdentifier] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public listRoomsAsAdministrator(pagingSortingParameters: PagingSortingParameters, managerIdentifier?: string, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).listRoomsAsAdministrator(pagingSortingParameters, managerIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves all rooms for PubSub managers
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public listRoomsAsManager(pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).listRoomsAsManager(pagingSortingParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves all rooms for PubSub managers accessing via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public listRoomsViaXRoad(memberId: string, pagingSortingParameters: PagingSortingParameters, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).listRoomsViaXRoad(memberId, pagingSortingParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify an existing room for PubSub administrators
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {ModifyRoomRequest} modifyRoomRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public modifyRoomAsAdministrator(memberId: string, roomId: string, modifyRoomRequest: ModifyRoomRequest, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).modifyRoomAsAdministrator(memberId, roomId, modifyRoomRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify an existing room for PubSub managers
     * @param {string} roomId Identifier of an existing active message room
     * @param {ModifyRoomRequest} modifyRoomRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public modifyRoomAsManager(roomId: string, modifyRoomRequest: ModifyRoomRequest, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).modifyRoomAsManager(roomId, modifyRoomRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify an existing room for PubSub managers accessing via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {ModifyRoomRequest} modifyRoomRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public modifyRoomViaXRoad(memberId: string, roomId: string, modifyRoomRequest: ModifyRoomRequest, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).modifyRoomViaXRoad(memberId, roomId, modifyRoomRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Terminates an existing active room for PubSub administrators
     * @param {string} memberId 
     * @param {string} roomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public terminateRoomAsAdministrator(memberId: string, roomId: string, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).terminateRoomAsAdministrator(memberId, roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Terminates an existing active room for PubSub managers
     * @param {string} roomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public terminateRoomAsManager(roomId: string, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).terminateRoomAsManager(roomId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Terminates an existing active room for PubSub managers accessing via XRoad network
     * @param {string} memberId 
     * @param {string} roomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomsApi
     */
    public terminateRoomViaXRoad(memberId: string, roomId: string, options?: AxiosRequestConfig) {
        return RoomsApiFp(this.configuration).terminateRoomViaXRoad(memberId, roomId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary A PubSub administrator can create subscription for a member to existing active room
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreateSubscriptionRequest} createSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionAsAdministrator: async (memberId: string, roomId: string, createSubscriptionRequest: CreateSubscriptionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('createSubscriptionAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('createSubscriptionAsAdministrator', 'roomId', roomId)
            // verify required parameter 'createSubscriptionRequest' is not null or undefined
            assertParamExists('createSubscriptionAsAdministrator', 'createSubscriptionRequest', createSubscriptionRequest)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}/subscriptions`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary A PubSub manager can create subscription for a member to existing active room
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreateSubscriptionRequest} createSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionAsManager: async (roomId: string, createSubscriptionRequest: CreateSubscriptionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('createSubscriptionAsManager', 'roomId', roomId)
            // verify required parameter 'createSubscriptionRequest' is not null or undefined
            assertParamExists('createSubscriptionAsManager', 'createSubscriptionRequest', createSubscriptionRequest)
            const localVarPath = `/api/rooms/{roomId}/subscriptions`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary A PubSub member can subscribe to existing active message room via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreateXRoadSubscriptionRequest} createXRoadSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createXRoadSubscriptionViaXRoad: async (memberId: string, roomId: string, createXRoadSubscriptionRequest: CreateXRoadSubscriptionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('createXRoadSubscriptionViaXRoad', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('createXRoadSubscriptionViaXRoad', 'roomId', roomId)
            // verify required parameter 'createXRoadSubscriptionRequest' is not null or undefined
            assertParamExists('createXRoadSubscriptionViaXRoad', 'createXRoadSubscriptionRequest', createXRoadSubscriptionRequest)
            const localVarPath = `/rooms/{memberId}/{roomId}/subscriptions`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createXRoadSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all subscription events delivery info for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId 
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {string} [eventId] 
         * @param {string} [eventTypeIdentifier] 
         * @param {string} [deliveryStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionEventDeliveriesAsAdministrator: async (memberId: string, roomId: string, subscriptionId: string, pagingSortingParameters: PagingSortingParameters, from?: string, to?: string, eventId?: string, eventTypeIdentifier?: string, deliveryStatus?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('listSubscriptionEventDeliveriesAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('listSubscriptionEventDeliveriesAsAdministrator', 'roomId', roomId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('listSubscriptionEventDeliveriesAsAdministrator', 'subscriptionId', subscriptionId)
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('listSubscriptionEventDeliveriesAsAdministrator', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}/subscriptions/{subscriptionId}/queue`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }

            if (eventTypeIdentifier !== undefined) {
                localVarQueryParameter['eventTypeIdentifier'] = eventTypeIdentifier;
            }

            if (deliveryStatus !== undefined) {
                localVarQueryParameter['deliveryStatus'] = deliveryStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all subscription events delivery info for PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId 
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {string} [eventId] 
         * @param {string} [eventTypeIdentifier] 
         * @param {string} [deliveryStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionEventDeliveriesAsManager: async (roomId: string, subscriptionId: string, pagingSortingParameters: PagingSortingParameters, from?: string, to?: string, eventId?: string, eventTypeIdentifier?: string, deliveryStatus?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('listSubscriptionEventDeliveriesAsManager', 'roomId', roomId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('listSubscriptionEventDeliveriesAsManager', 'subscriptionId', subscriptionId)
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('listSubscriptionEventDeliveriesAsManager', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/api/rooms/{roomId}/subscriptions/{subscriptionId}/queue`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }

            if (eventTypeIdentifier !== undefined) {
                localVarQueryParameter['eventTypeIdentifier'] = eventTypeIdentifier;
            }

            if (deliveryStatus !== undefined) {
                localVarQueryParameter['deliveryStatus'] = deliveryStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all subscription events delivery info accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId 
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {string} [eventId] 
         * @param {string} [eventTypeIdentifier] 
         * @param {string} [deliveryStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionEventDeliveriesViaXRoad: async (memberId: string, roomId: string, subscriptionId: string, pagingSortingParameters: PagingSortingParameters, from?: string, to?: string, eventId?: string, eventTypeIdentifier?: string, deliveryStatus?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('listSubscriptionEventDeliveriesViaXRoad', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('listSubscriptionEventDeliveriesViaXRoad', 'roomId', roomId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('listSubscriptionEventDeliveriesViaXRoad', 'subscriptionId', subscriptionId)
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('listSubscriptionEventDeliveriesViaXRoad', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/rooms/{memberId}/{roomId}/subscriptions/{subscriptionId}/queue`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }

            if (eventTypeIdentifier !== undefined) {
                localVarQueryParameter['eventTypeIdentifier'] = eventTypeIdentifier;
            }

            if (deliveryStatus !== undefined) {
                localVarQueryParameter['deliveryStatus'] = deliveryStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all subscriptions in a message room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {ListSubscriptionsAsAdministratorStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionsAsAdministrator: async (memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, status?: ListSubscriptionsAsAdministratorStatusEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('listSubscriptionsAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('listSubscriptionsAsAdministrator', 'roomId', roomId)
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('listSubscriptionsAsAdministrator', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}/subscriptions`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all subscriptions in a message room for PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {ListSubscriptionsAsManagerStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionsAsManager: async (roomId: string, pagingSortingParameters: PagingSortingParameters, status?: ListSubscriptionsAsManagerStatusEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('listSubscriptionsAsManager', 'roomId', roomId)
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('listSubscriptionsAsManager', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/api/rooms/{roomId}/subscriptions`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all subscriptions in a message room for PubSub members accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {ListSubscriptionsViaXRoadStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionsViaXRoad: async (memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, status?: ListSubscriptionsViaXRoadStatusEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('listSubscriptionsViaXRoad', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('listSubscriptionsViaXRoad', 'roomId', roomId)
            // verify required parameter 'pagingSortingParameters' is not null or undefined
            assertParamExists('listSubscriptionsViaXRoad', 'pagingSortingParameters', pagingSortingParameters)
            const localVarPath = `/rooms/{memberId}/{roomId}/subscriptions`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (pagingSortingParameters !== undefined) {
                localVarQueryParameter['pagingSortingParameters'] = pagingSortingParameters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unsubscribe a PubSub member\'s subscription from existing active message room as PubSub administrator
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId The subscription id that belongs to the member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateSubscriptionAsAdministrator: async (memberId: string, roomId: string, subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('terminateSubscriptionAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('terminateSubscriptionAsAdministrator', 'roomId', roomId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('terminateSubscriptionAsAdministrator', 'subscriptionId', subscriptionId)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}/subscriptions/{subscriptionId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unsubscribe a PubSub member\'s subscription from existing message room as PubSUb manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId The subscription id that belongs to the member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateSubscriptionAsManager: async (roomId: string, subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('terminateSubscriptionAsManager', 'roomId', roomId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('terminateSubscriptionAsManager', 'subscriptionId', subscriptionId)
            const localVarPath = `/api/rooms/{roomId}/subscriptions/{subscriptionId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unsubscribe a PubSub member\'s subscription from existing active message room via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId The subscription id that belongs to the member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateSubscriptionViaXRoad: async (memberId: string, roomId: string, subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('terminateSubscriptionViaXRoad', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('terminateSubscriptionViaXRoad', 'roomId', roomId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('terminateSubscriptionViaXRoad', 'subscriptionId', subscriptionId)
            const localVarPath = `/rooms/{memberId}/{roomId}/subscriptions/{subscriptionId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Approve or reject a PubSub member\'s subscription as PubSub administrator
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId The subscription id that belongs to the member
         * @param {UpdateSubscriptionStatusRequest} updateSubscriptionStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionStatusAsAdministrator: async (memberId: string, roomId: string, subscriptionId: string, updateSubscriptionStatusRequest: UpdateSubscriptionStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('updateSubscriptionStatusAsAdministrator', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('updateSubscriptionStatusAsAdministrator', 'roomId', roomId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('updateSubscriptionStatusAsAdministrator', 'subscriptionId', subscriptionId)
            // verify required parameter 'updateSubscriptionStatusRequest' is not null or undefined
            assertParamExists('updateSubscriptionStatusAsAdministrator', 'updateSubscriptionStatusRequest', updateSubscriptionStatusRequest)
            const localVarPath = `/api/admin/rooms/{memberId}/{roomId}/subscriptions/{subscriptionId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSubscriptionStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Approve or reject a PubSub member\'s subscription as PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId The subscription id that belongs to the member
         * @param {UpdateSubscriptionStatusRequest} updateSubscriptionStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionStatusAsManager: async (roomId: string, subscriptionId: string, updateSubscriptionStatusRequest: UpdateSubscriptionStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('updateSubscriptionStatusAsManager', 'roomId', roomId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('updateSubscriptionStatusAsManager', 'subscriptionId', subscriptionId)
            // verify required parameter 'updateSubscriptionStatusRequest' is not null or undefined
            assertParamExists('updateSubscriptionStatusAsManager', 'updateSubscriptionStatusRequest', updateSubscriptionStatusRequest)
            const localVarPath = `/api/rooms/{roomId}/subscriptions/{subscriptionId}`
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSubscriptionStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Approve or reject a PubSub member\'s subscription via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId The subscription id that belongs to the member
         * @param {UpdateSubscriptionStatusRequest} updateSubscriptionStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionStatusViaXRoad: async (memberId: string, roomId: string, subscriptionId: string, updateSubscriptionStatusRequest: UpdateSubscriptionStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('updateSubscriptionStatusViaXRoad', 'memberId', memberId)
            // verify required parameter 'roomId' is not null or undefined
            assertParamExists('updateSubscriptionStatusViaXRoad', 'roomId', roomId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('updateSubscriptionStatusViaXRoad', 'subscriptionId', subscriptionId)
            // verify required parameter 'updateSubscriptionStatusRequest' is not null or undefined
            assertParamExists('updateSubscriptionStatusViaXRoad', 'updateSubscriptionStatusRequest', updateSubscriptionStatusRequest)
            const localVarPath = `/rooms/{memberId}/{roomId}/subscriptions/{subscriptionId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)))
                .replace(`{${"roomId"}}`, encodeURIComponent(String(roomId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSubscriptionStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary A PubSub administrator can create subscription for a member to existing active room
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreateSubscriptionRequest} createSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscriptionAsAdministrator(memberId: string, roomId: string, createSubscriptionRequest: CreateSubscriptionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscriptionAsAdministrator(memberId, roomId, createSubscriptionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary A PubSub manager can create subscription for a member to existing active room
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreateSubscriptionRequest} createSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubscriptionAsManager(roomId: string, createSubscriptionRequest: CreateSubscriptionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscriptionAsManager(roomId, createSubscriptionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary A PubSub member can subscribe to existing active message room via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreateXRoadSubscriptionRequest} createXRoadSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createXRoadSubscriptionViaXRoad(memberId: string, roomId: string, createXRoadSubscriptionRequest: CreateXRoadSubscriptionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createXRoadSubscriptionViaXRoad(memberId, roomId, createXRoadSubscriptionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all subscription events delivery info for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId 
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {string} [eventId] 
         * @param {string} [eventTypeIdentifier] 
         * @param {string} [deliveryStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionEventDeliveriesAsAdministrator(memberId: string, roomId: string, subscriptionId: string, pagingSortingParameters: PagingSortingParameters, from?: string, to?: string, eventId?: string, eventTypeIdentifier?: string, deliveryStatus?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSubscriptionEventDeliveriesList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubscriptionEventDeliveriesAsAdministrator(memberId, roomId, subscriptionId, pagingSortingParameters, from, to, eventId, eventTypeIdentifier, deliveryStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all subscription events delivery info for PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId 
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {string} [eventId] 
         * @param {string} [eventTypeIdentifier] 
         * @param {string} [deliveryStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionEventDeliveriesAsManager(roomId: string, subscriptionId: string, pagingSortingParameters: PagingSortingParameters, from?: string, to?: string, eventId?: string, eventTypeIdentifier?: string, deliveryStatus?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSubscriptionEventDeliveriesList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubscriptionEventDeliveriesAsManager(roomId, subscriptionId, pagingSortingParameters, from, to, eventId, eventTypeIdentifier, deliveryStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all subscription events delivery info accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId 
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {string} [eventId] 
         * @param {string} [eventTypeIdentifier] 
         * @param {string} [deliveryStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionEventDeliveriesViaXRoad(memberId: string, roomId: string, subscriptionId: string, pagingSortingParameters: PagingSortingParameters, from?: string, to?: string, eventId?: string, eventTypeIdentifier?: string, deliveryStatus?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSubscriptionEventDeliveriesList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubscriptionEventDeliveriesViaXRoad(memberId, roomId, subscriptionId, pagingSortingParameters, from, to, eventId, eventTypeIdentifier, deliveryStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all subscriptions in a message room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {ListSubscriptionsAsAdministratorStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionsAsAdministrator(memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, status?: ListSubscriptionsAsAdministratorStatusEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSubscriptionsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubscriptionsAsAdministrator(memberId, roomId, pagingSortingParameters, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all subscriptions in a message room for PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {ListSubscriptionsAsManagerStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionsAsManager(roomId: string, pagingSortingParameters: PagingSortingParameters, status?: ListSubscriptionsAsManagerStatusEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSubscriptionsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubscriptionsAsManager(roomId, pagingSortingParameters, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all subscriptions in a message room for PubSub members accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {ListSubscriptionsViaXRoadStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubscriptionsViaXRoad(memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, status?: ListSubscriptionsViaXRoadStatusEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSubscriptionsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubscriptionsViaXRoad(memberId, roomId, pagingSortingParameters, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unsubscribe a PubSub member\'s subscription from existing active message room as PubSub administrator
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId The subscription id that belongs to the member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateSubscriptionAsAdministrator(memberId: string, roomId: string, subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateSubscriptionAsAdministrator(memberId, roomId, subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unsubscribe a PubSub member\'s subscription from existing message room as PubSUb manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId The subscription id that belongs to the member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateSubscriptionAsManager(roomId: string, subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateSubscriptionAsManager(roomId, subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unsubscribe a PubSub member\'s subscription from existing active message room via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId The subscription id that belongs to the member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async terminateSubscriptionViaXRoad(memberId: string, roomId: string, subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.terminateSubscriptionViaXRoad(memberId, roomId, subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Approve or reject a PubSub member\'s subscription as PubSub administrator
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId The subscription id that belongs to the member
         * @param {UpdateSubscriptionStatusRequest} updateSubscriptionStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscriptionStatusAsAdministrator(memberId: string, roomId: string, subscriptionId: string, updateSubscriptionStatusRequest: UpdateSubscriptionStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscriptionStatusAsAdministrator(memberId, roomId, subscriptionId, updateSubscriptionStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Approve or reject a PubSub member\'s subscription as PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId The subscription id that belongs to the member
         * @param {UpdateSubscriptionStatusRequest} updateSubscriptionStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscriptionStatusAsManager(roomId: string, subscriptionId: string, updateSubscriptionStatusRequest: UpdateSubscriptionStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscriptionStatusAsManager(roomId, subscriptionId, updateSubscriptionStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Approve or reject a PubSub member\'s subscription via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId The subscription id that belongs to the member
         * @param {UpdateSubscriptionStatusRequest} updateSubscriptionStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubscriptionStatusViaXRoad(memberId: string, roomId: string, subscriptionId: string, updateSubscriptionStatusRequest: UpdateSubscriptionStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscriptionStatusViaXRoad(memberId, roomId, subscriptionId, updateSubscriptionStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionsApiFp(configuration)
    return {
        /**
         * 
         * @summary A PubSub administrator can create subscription for a member to existing active room
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreateSubscriptionRequest} createSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionAsAdministrator(memberId: string, roomId: string, createSubscriptionRequest: CreateSubscriptionRequest, options?: any): AxiosPromise<CreateSubscriptionResponse> {
            return localVarFp.createSubscriptionAsAdministrator(memberId, roomId, createSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary A PubSub manager can create subscription for a member to existing active room
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreateSubscriptionRequest} createSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionAsManager(roomId: string, createSubscriptionRequest: CreateSubscriptionRequest, options?: any): AxiosPromise<CreateSubscriptionResponse> {
            return localVarFp.createSubscriptionAsManager(roomId, createSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary A PubSub member can subscribe to existing active message room via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {CreateXRoadSubscriptionRequest} createXRoadSubscriptionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createXRoadSubscriptionViaXRoad(memberId: string, roomId: string, createXRoadSubscriptionRequest: CreateXRoadSubscriptionRequest, options?: any): AxiosPromise<CreateSubscriptionResponse> {
            return localVarFp.createXRoadSubscriptionViaXRoad(memberId, roomId, createXRoadSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all subscription events delivery info for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId 
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {string} [eventId] 
         * @param {string} [eventTypeIdentifier] 
         * @param {string} [deliveryStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionEventDeliveriesAsAdministrator(memberId: string, roomId: string, subscriptionId: string, pagingSortingParameters: PagingSortingParameters, from?: string, to?: string, eventId?: string, eventTypeIdentifier?: string, deliveryStatus?: string, options?: any): AxiosPromise<PaginatedSubscriptionEventDeliveriesList> {
            return localVarFp.listSubscriptionEventDeliveriesAsAdministrator(memberId, roomId, subscriptionId, pagingSortingParameters, from, to, eventId, eventTypeIdentifier, deliveryStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all subscription events delivery info for PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId 
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {string} [eventId] 
         * @param {string} [eventTypeIdentifier] 
         * @param {string} [deliveryStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionEventDeliveriesAsManager(roomId: string, subscriptionId: string, pagingSortingParameters: PagingSortingParameters, from?: string, to?: string, eventId?: string, eventTypeIdentifier?: string, deliveryStatus?: string, options?: any): AxiosPromise<PaginatedSubscriptionEventDeliveriesList> {
            return localVarFp.listSubscriptionEventDeliveriesAsManager(roomId, subscriptionId, pagingSortingParameters, from, to, eventId, eventTypeIdentifier, deliveryStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all subscription events delivery info accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId 
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {string} [eventId] 
         * @param {string} [eventTypeIdentifier] 
         * @param {string} [deliveryStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionEventDeliveriesViaXRoad(memberId: string, roomId: string, subscriptionId: string, pagingSortingParameters: PagingSortingParameters, from?: string, to?: string, eventId?: string, eventTypeIdentifier?: string, deliveryStatus?: string, options?: any): AxiosPromise<PaginatedSubscriptionEventDeliveriesList> {
            return localVarFp.listSubscriptionEventDeliveriesViaXRoad(memberId, roomId, subscriptionId, pagingSortingParameters, from, to, eventId, eventTypeIdentifier, deliveryStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all subscriptions in a message room for PubSub administrators
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {ListSubscriptionsAsAdministratorStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionsAsAdministrator(memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, status?: ListSubscriptionsAsAdministratorStatusEnum, options?: any): AxiosPromise<PaginatedSubscriptionsList> {
            return localVarFp.listSubscriptionsAsAdministrator(memberId, roomId, pagingSortingParameters, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all subscriptions in a message room for PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {ListSubscriptionsAsManagerStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionsAsManager(roomId: string, pagingSortingParameters: PagingSortingParameters, status?: ListSubscriptionsAsManagerStatusEnum, options?: any): AxiosPromise<PaginatedSubscriptionsList> {
            return localVarFp.listSubscriptionsAsManager(roomId, pagingSortingParameters, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all subscriptions in a message room for PubSub members accessing via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {PagingSortingParameters} pagingSortingParameters 
         * @param {ListSubscriptionsViaXRoadStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubscriptionsViaXRoad(memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, status?: ListSubscriptionsViaXRoadStatusEnum, options?: any): AxiosPromise<PaginatedSubscriptionsList> {
            return localVarFp.listSubscriptionsViaXRoad(memberId, roomId, pagingSortingParameters, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unsubscribe a PubSub member\'s subscription from existing active message room as PubSub administrator
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId The subscription id that belongs to the member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateSubscriptionAsAdministrator(memberId: string, roomId: string, subscriptionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.terminateSubscriptionAsAdministrator(memberId, roomId, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unsubscribe a PubSub member\'s subscription from existing message room as PubSUb manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId The subscription id that belongs to the member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateSubscriptionAsManager(roomId: string, subscriptionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.terminateSubscriptionAsManager(roomId, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unsubscribe a PubSub member\'s subscription from existing active message room via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId The subscription id that belongs to the member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminateSubscriptionViaXRoad(memberId: string, roomId: string, subscriptionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.terminateSubscriptionViaXRoad(memberId, roomId, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Approve or reject a PubSub member\'s subscription as PubSub administrator
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId The subscription id that belongs to the member
         * @param {UpdateSubscriptionStatusRequest} updateSubscriptionStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionStatusAsAdministrator(memberId: string, roomId: string, subscriptionId: string, updateSubscriptionStatusRequest: UpdateSubscriptionStatusRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateSubscriptionStatusAsAdministrator(memberId, roomId, subscriptionId, updateSubscriptionStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Approve or reject a PubSub member\'s subscription as PubSub manager
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId The subscription id that belongs to the member
         * @param {UpdateSubscriptionStatusRequest} updateSubscriptionStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionStatusAsManager(roomId: string, subscriptionId: string, updateSubscriptionStatusRequest: UpdateSubscriptionStatusRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateSubscriptionStatusAsManager(roomId, subscriptionId, updateSubscriptionStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Approve or reject a PubSub member\'s subscription via XRoad network
         * @param {string} memberId The identifier of the member
         * @param {string} roomId Identifier of an existing active message room
         * @param {string} subscriptionId The subscription id that belongs to the member
         * @param {UpdateSubscriptionStatusRequest} updateSubscriptionStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionStatusViaXRoad(memberId: string, roomId: string, subscriptionId: string, updateSubscriptionStatusRequest: UpdateSubscriptionStatusRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateSubscriptionStatusViaXRoad(memberId, roomId, subscriptionId, updateSubscriptionStatusRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * 
     * @summary A PubSub administrator can create subscription for a member to existing active room
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {CreateSubscriptionRequest} createSubscriptionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public createSubscriptionAsAdministrator(memberId: string, roomId: string, createSubscriptionRequest: CreateSubscriptionRequest, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).createSubscriptionAsAdministrator(memberId, roomId, createSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary A PubSub manager can create subscription for a member to existing active room
     * @param {string} roomId Identifier of an existing active message room
     * @param {CreateSubscriptionRequest} createSubscriptionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public createSubscriptionAsManager(roomId: string, createSubscriptionRequest: CreateSubscriptionRequest, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).createSubscriptionAsManager(roomId, createSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary A PubSub member can subscribe to existing active message room via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {CreateXRoadSubscriptionRequest} createXRoadSubscriptionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public createXRoadSubscriptionViaXRoad(memberId: string, roomId: string, createXRoadSubscriptionRequest: CreateXRoadSubscriptionRequest, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).createXRoadSubscriptionViaXRoad(memberId, roomId, createXRoadSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all subscription events delivery info for PubSub administrators
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} subscriptionId 
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {string} [eventId] 
     * @param {string} [eventTypeIdentifier] 
     * @param {string} [deliveryStatus] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public listSubscriptionEventDeliveriesAsAdministrator(memberId: string, roomId: string, subscriptionId: string, pagingSortingParameters: PagingSortingParameters, from?: string, to?: string, eventId?: string, eventTypeIdentifier?: string, deliveryStatus?: string, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).listSubscriptionEventDeliveriesAsAdministrator(memberId, roomId, subscriptionId, pagingSortingParameters, from, to, eventId, eventTypeIdentifier, deliveryStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all subscription events delivery info for PubSub manager
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} subscriptionId 
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {string} [eventId] 
     * @param {string} [eventTypeIdentifier] 
     * @param {string} [deliveryStatus] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public listSubscriptionEventDeliveriesAsManager(roomId: string, subscriptionId: string, pagingSortingParameters: PagingSortingParameters, from?: string, to?: string, eventId?: string, eventTypeIdentifier?: string, deliveryStatus?: string, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).listSubscriptionEventDeliveriesAsManager(roomId, subscriptionId, pagingSortingParameters, from, to, eventId, eventTypeIdentifier, deliveryStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all subscription events delivery info accessing via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} subscriptionId 
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {string} [from] 
     * @param {string} [to] 
     * @param {string} [eventId] 
     * @param {string} [eventTypeIdentifier] 
     * @param {string} [deliveryStatus] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public listSubscriptionEventDeliveriesViaXRoad(memberId: string, roomId: string, subscriptionId: string, pagingSortingParameters: PagingSortingParameters, from?: string, to?: string, eventId?: string, eventTypeIdentifier?: string, deliveryStatus?: string, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).listSubscriptionEventDeliveriesViaXRoad(memberId, roomId, subscriptionId, pagingSortingParameters, from, to, eventId, eventTypeIdentifier, deliveryStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all subscriptions in a message room for PubSub administrators
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {ListSubscriptionsAsAdministratorStatusEnum} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public listSubscriptionsAsAdministrator(memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, status?: ListSubscriptionsAsAdministratorStatusEnum, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).listSubscriptionsAsAdministrator(memberId, roomId, pagingSortingParameters, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all subscriptions in a message room for PubSub manager
     * @param {string} roomId Identifier of an existing active message room
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {ListSubscriptionsAsManagerStatusEnum} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public listSubscriptionsAsManager(roomId: string, pagingSortingParameters: PagingSortingParameters, status?: ListSubscriptionsAsManagerStatusEnum, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).listSubscriptionsAsManager(roomId, pagingSortingParameters, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all subscriptions in a message room for PubSub members accessing via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {PagingSortingParameters} pagingSortingParameters 
     * @param {ListSubscriptionsViaXRoadStatusEnum} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public listSubscriptionsViaXRoad(memberId: string, roomId: string, pagingSortingParameters: PagingSortingParameters, status?: ListSubscriptionsViaXRoadStatusEnum, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).listSubscriptionsViaXRoad(memberId, roomId, pagingSortingParameters, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unsubscribe a PubSub member\'s subscription from existing active message room as PubSub administrator
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} subscriptionId The subscription id that belongs to the member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public terminateSubscriptionAsAdministrator(memberId: string, roomId: string, subscriptionId: string, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).terminateSubscriptionAsAdministrator(memberId, roomId, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unsubscribe a PubSub member\'s subscription from existing message room as PubSUb manager
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} subscriptionId The subscription id that belongs to the member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public terminateSubscriptionAsManager(roomId: string, subscriptionId: string, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).terminateSubscriptionAsManager(roomId, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unsubscribe a PubSub member\'s subscription from existing active message room via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} subscriptionId The subscription id that belongs to the member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public terminateSubscriptionViaXRoad(memberId: string, roomId: string, subscriptionId: string, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).terminateSubscriptionViaXRoad(memberId, roomId, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Approve or reject a PubSub member\'s subscription as PubSub administrator
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} subscriptionId The subscription id that belongs to the member
     * @param {UpdateSubscriptionStatusRequest} updateSubscriptionStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public updateSubscriptionStatusAsAdministrator(memberId: string, roomId: string, subscriptionId: string, updateSubscriptionStatusRequest: UpdateSubscriptionStatusRequest, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).updateSubscriptionStatusAsAdministrator(memberId, roomId, subscriptionId, updateSubscriptionStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Approve or reject a PubSub member\'s subscription as PubSub manager
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} subscriptionId The subscription id that belongs to the member
     * @param {UpdateSubscriptionStatusRequest} updateSubscriptionStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public updateSubscriptionStatusAsManager(roomId: string, subscriptionId: string, updateSubscriptionStatusRequest: UpdateSubscriptionStatusRequest, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).updateSubscriptionStatusAsManager(roomId, subscriptionId, updateSubscriptionStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Approve or reject a PubSub member\'s subscription via XRoad network
     * @param {string} memberId The identifier of the member
     * @param {string} roomId Identifier of an existing active message room
     * @param {string} subscriptionId The subscription id that belongs to the member
     * @param {UpdateSubscriptionStatusRequest} updateSubscriptionStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public updateSubscriptionStatusViaXRoad(memberId: string, roomId: string, subscriptionId: string, updateSubscriptionStatusRequest: UpdateSubscriptionStatusRequest, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).updateSubscriptionStatusViaXRoad(memberId, roomId, subscriptionId, updateSubscriptionStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListSubscriptionsAsAdministratorStatusEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Rejected: 'REJECTED',
    Terminated: 'TERMINATED'
} as const;
export type ListSubscriptionsAsAdministratorStatusEnum = typeof ListSubscriptionsAsAdministratorStatusEnum[keyof typeof ListSubscriptionsAsAdministratorStatusEnum];
/**
 * @export
 */
export const ListSubscriptionsAsManagerStatusEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Rejected: 'REJECTED',
    Terminated: 'TERMINATED'
} as const;
export type ListSubscriptionsAsManagerStatusEnum = typeof ListSubscriptionsAsManagerStatusEnum[keyof typeof ListSubscriptionsAsManagerStatusEnum];
/**
 * @export
 */
export const ListSubscriptionsViaXRoadStatusEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Rejected: 'REJECTED',
    Terminated: 'TERMINATED'
} as const;
export type ListSubscriptionsViaXRoadStatusEnum = typeof ListSubscriptionsViaXRoadStatusEnum[keyof typeof ListSubscriptionsViaXRoadStatusEnum];


